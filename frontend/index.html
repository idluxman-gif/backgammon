<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Backgammon</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700;800&display=swap" rel="stylesheet">
  <style>
    /* ── Reset ──────────────────────────────────── */
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html { height: 100%; }

    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Inter', 'Segoe UI', system-ui, -apple-system, sans-serif;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      position: relative;
    }

    /* ── Game Root (fixed design viewport, scaled to fit) ── */
    #game-root {
      width: 1280px;
      height: 800px;
      position: fixed;
      top: 0;
      left: 0;
      transform-origin: top left;
      overflow: hidden;
    }

    /* ── Screen System ─────────────────────────── */
    .screen {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      transition: opacity 0.4s ease;
      opacity: 1;
    }
    .screen.hidden { opacity: 0; pointer-events: none; }
    .screen.removed { display: none; }

    /* ── Setup Screen ──────────────────────────── */
    .setup-screen { z-index: 10; }

    .setup-screen h1 {
      font-size: 1.6rem;
      font-weight: 300;
      letter-spacing: 0.3em;
      text-transform: uppercase;
      color: #c9a96e;
      margin-bottom: 20px;
    }

    .setup-card {
      background: #2c2c3a;
      border-radius: 16px;
      padding: 32px 36px;
      max-width: 460px;
      width: 460px;
      border: 1px solid rgba(201, 169, 110, 0.2);
      box-shadow: 0 8px 32px rgba(0,0,0,0.4);
    }

    /* ── Mode Selection ──────────────────────────── */
    .mode-select {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 14px;
    }
    .mode-select.hidden { display: none; }

    .mode-buttons { display: flex; gap: 12px; justify-content: center; }

    .mode-btn {
      padding: 10px 24px;
      font-size: 0.9rem;
      font-weight: 600;
      letter-spacing: 0.03em;
      background: rgba(201, 169, 110, 0.12);
      color: rgba(201, 169, 110, 0.7);
      border: 2px solid rgba(201, 169, 110, 0.25);
      border-radius: 8px;
      cursor: pointer;
      transition: background 0.2s, transform 0.1s, border-color 0.2s, color 0.2s;
      user-select: none;
      font-family: inherit;
    }
    .mode-btn:hover { background: rgba(201, 169, 110, 0.22); border-color: rgba(201, 169, 110, 0.5); color: #c9a96e; }
    .mode-btn:active { transform: scale(0.96); }
    .mode-btn.active { background: #c9a96e; color: #1a1a2e; border-color: #c9a96e; }
    .mode-btn.active:hover { background: #dfc08a; border-color: #dfc08a; }

    /* ── Avatar Picker ───────────────────────────── */
    .avatar-picker-section { display: flex; flex-direction: column; align-items: center; gap: 6px; }
    .avatar-picker-label {
      font-size: 0.7rem; font-weight: 600; letter-spacing: 0.04em;
      text-transform: uppercase; color: rgba(255,255,255,0.45); user-select: none;
    }
    .avatar-picker-grid { display: flex; gap: 6px; justify-content: center; flex-wrap: wrap; }
    .avatar-option {
      width: 38px; height: 38px; border-radius: 50%;
      border: 2px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.04);
      cursor: pointer; display: flex; align-items: center; justify-content: center;
      padding: 7px; transition: border-color 0.2s, box-shadow 0.2s;
    }
    .avatar-option svg { width: 20px; height: 20px; fill: rgba(255,255,255,0.45); transition: fill 0.2s; }
    .avatar-option:hover { border-color: rgba(201, 169, 110, 0.4); }
    .avatar-option:hover svg { fill: rgba(255,255,255,0.65); }
    .avatar-option.selected { border-color: #c9a96e; box-shadow: 0 0 0 3px rgba(201, 169, 110, 0.35); }
    .avatar-option.selected svg { fill: #c9a96e; }

    .avatars-row {
      display: flex; gap: 24px; justify-content: center; align-items: flex-start;
    }

    /* ── Player Name Inputs ─────────────────────── */
    .player-name-inputs {
      display: flex; gap: 24px; align-items: flex-start; justify-content: center;
    }
    .player-name-inputs .name-field { display: flex; flex-direction: column; gap: 3px; align-items: center; }
    .player-name-inputs .name-field label {
      font-size: 0.7rem; font-weight: 600; letter-spacing: 0.04em;
      text-transform: uppercase; color: rgba(255,255,255,0.45); user-select: none;
    }
    .player-name-inputs .name-field input {
      width: 150px; padding: 7px 10px; font-size: 0.88rem; font-weight: 600;
      color: #e0e0e0; background: #1a1a2e;
      border: 1px solid rgba(201, 169, 110, 0.3); border-radius: 6px;
      outline: none; transition: border-color 0.2s; font-family: inherit;
    }
    .player-name-inputs .name-field input:focus { border-color: #c9a96e; }
    .player-name-inputs .name-field input::placeholder { color: rgba(255,255,255,0.2); }

    .player-name-inputs .name-dot {
      display: inline-block; width: 10px; height: 10px; border-radius: 50%;
      margin-right: 4px; vertical-align: middle; border: 1.5px solid rgba(255,255,255,0.3);
    }
    .player-name-inputs .name-dot.white { background: radial-gradient(circle at 35% 35%, #fff, #ccc); border-color: rgba(0,0,0,0.2); }
    .player-name-inputs .name-dot.black { background: radial-gradient(circle at 35% 35%, #555, #1a1a1a); }

    /* ── Settings Area ──────────────────────────── */
    .settings-area {
      min-height: 80px; display: flex; flex-direction: column; align-items: center;
      justify-content: center; gap: 8px;
    }

    .start-game-btn {
      padding: 13px 40px; font-size: 1rem; font-weight: 700;
      letter-spacing: 0.06em; text-transform: uppercase;
      background: linear-gradient(135deg, #c9a96e, #e8d5a3);
      color: #1a1a2e; border: none; border-radius: 10px;
      cursor: pointer; transition: transform 0.1s, box-shadow 0.2s;
      user-select: none; font-family: inherit;
      box-shadow: 0 4px 16px rgba(201, 169, 110, 0.3);
    }
    .start-game-btn:hover { transform: scale(1.03); box-shadow: 0 6px 20px rgba(201, 169, 110, 0.45); }
    .start-game-btn:active { transform: scale(0.97); }

    /* ── Cube Settings ───────────────────────────── */
    .cube-settings {
      display: flex; align-items: center; gap: 12px;
      padding: 8px 14px; background: rgba(255,255,255,0.03);
      border-radius: 8px; border: 1px solid rgba(255,255,255,0.06);
    }
    .cube-settings-label {
      font-size: 0.75rem; font-weight: 600; letter-spacing: 0.04em;
      color: rgba(255,255,255,0.45); text-transform: uppercase; user-select: none;
    }
    .cube-settings .toggle-switch { width: 36px; height: 20px; }
    .cube-settings .toggle-knob { width: 14px; height: 14px; top: 3px; left: 3px; }
    .cube-settings .toggle-switch input:checked ~ .toggle-knob { transform: translateX(16px); }

    .cube-max-wrapper { display: none; align-items: center; gap: 6px; }
    .cube-max-wrapper.visible { display: flex; }
    .cube-max-wrapper label { font-size: 0.72rem; color: rgba(255,255,255,0.4); text-transform: uppercase; letter-spacing: 0.03em; user-select: none; }
    .cube-max-select {
      background: #1a1a2e; color: #c9a96e;
      border: 1px solid rgba(201, 169, 110, 0.3); border-radius: 4px;
      padding: 2px 6px; font-size: 0.78rem; font-weight: 600; cursor: pointer; font-family: inherit;
    }

    /* ── AI Difficulty ────────────────────────────── */
    .ai-settings { display: none; flex-direction: column; align-items: center; gap: 6px; }
    .ai-settings.visible { display: flex; }
    .ai-settings .ai-label {
      font-size: 0.7rem; font-weight: 600; letter-spacing: 0.04em;
      text-transform: uppercase; color: rgba(255,255,255,0.45); user-select: none;
    }
    .ai-difficulty-btns { display: flex; gap: 8px; }
    .ai-diff-btn {
      padding: 7px 14px; font-size: 0.78rem; font-weight: 600; letter-spacing: 0.02em;
      background: #1a1a2e; color: rgba(255,255,255,0.45);
      border: 2px solid rgba(255,255,255,0.1); border-radius: 6px;
      cursor: pointer; transition: background 0.2s, border-color 0.2s, color 0.2s, transform 0.1s;
      user-select: none; font-family: inherit;
    }
    .ai-diff-btn:hover { border-color: rgba(201, 169, 110, 0.35); color: rgba(255,255,255,0.65); }
    .ai-diff-btn:active { transform: scale(0.96); }
    .ai-diff-btn.selected { background: rgba(201, 169, 110, 0.12); border-color: #c9a96e; color: #c9a96e; }

    /* ── AI Thinking Dots ────────────────────────── */
    .ai-thinking-dots { display: inline-flex; gap: 3px; }
    .ai-thinking-dots span { width: 5px; height: 5px; border-radius: 50%; background: #c9a96e; animation: ai-dot-bounce 1.2s infinite; }
    .ai-thinking-dots span:nth-child(2) { animation-delay: 0.2s; }
    .ai-thinking-dots span:nth-child(3) { animation-delay: 0.4s; }
    @keyframes ai-dot-bounce {
      0%, 60%, 100% { opacity: 0.3; transform: translateY(0); }
      30% { opacity: 1; transform: translateY(-3px); }
    }

    /* ── Toggle Switch (shared) ──────────────────── */
    .toggle-switch {
      position: relative; width: 40px; height: 22px; cursor: pointer; user-select: none;
    }
    .toggle-switch input { opacity: 0; width: 0; height: 0; position: absolute; }
    .toggle-track {
      position: absolute; top: 0; left: 0; right: 0; bottom: 0;
      background: #8b3a3a; border-radius: 11px; transition: background 0.25s;
    }
    .toggle-switch input:checked + .toggle-track { background: #3a8b4a; }
    .toggle-knob {
      position: absolute; top: 3px; left: 3px; width: 16px; height: 16px;
      background: #fff; border-radius: 50%; transition: transform 0.25s;
      box-shadow: 0 1px 4px rgba(0,0,0,0.3);
    }
    .toggle-switch input:checked ~ .toggle-knob { transform: translateX(18px); }

    /* ═══════════════════════════════════════════════
       GAME SCREEN
       ═══════════════════════════════════════════════ */
    .game-screen {
      z-index: 5; justify-content: space-between;
      padding: 8px 26px;
    }

    /* ── Top Bar ─────────────────────────────────── */
    .top-bar {
      display: flex; align-items: center; justify-content: space-between;
      width: 100%; max-width: 960px;
      height: 48px;
      padding: 0 13px; flex-shrink: 0;
    }
    .top-bar-player {
      display: flex; align-items: center; gap: 8px;
      padding: 4px 12px; border-radius: 8px;
      border-bottom: 2px solid transparent;
      transition: border-color 0.3s, box-shadow 0.3s;
    }
    .top-bar-player.active {
      border-bottom-color: #c9a96e;
      box-shadow: 0 3px 10px rgba(201, 169, 110, 0.25);
    }
    .top-bar-avatar {
      width: 28px; height: 28px; display: flex; align-items: center; justify-content: center;
    }
    .top-bar-avatar svg { width: 24px; height: 24px; fill: #c9a96e; }
    .top-bar-name {
      font-size: 0.85rem; font-weight: 600; color: #e0e0e0; white-space: nowrap;
    }
    .top-bar-score {
      font-size: 1.1rem; font-weight: 800; color: #c9a96e; min-width: 18px; text-align: center;
    }
    .top-bar-center {
      flex: 1; text-align: center; min-width: 0; padding: 0 12px;
    }
    .sr-only { position: absolute; width: 1px; height: 1px; overflow: hidden; clip: rect(0,0,0,0); }

    /* ── Status Area ─────────────────────────────── */
    .status-area {
      text-align: center; width: 100%;
      display: flex; flex-direction: column; align-items: center; justify-content: center;
    }
    .status-bar {
      font-size: 0.85rem; color: #e0e0e0; line-height: 1.4;
      white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 100%;
    }
    .ai-thinking-line {
      font-size: 0.75rem; color: rgba(201, 169, 110, 0.7); font-style: italic;
      display: flex; align-items: center; justify-content: center;
      gap: 6px; height: 18px; visibility: hidden;
    }
    .ai-thinking-line.visible { visibility: visible; }

    .turn-indicator {
      display: inline-block; width: 12px; height: 12px; border-radius: 50%;
      margin-right: 5px; vertical-align: middle; border: 2px solid rgba(255,255,255,0.4);
    }
    .turn-indicator.white { background: radial-gradient(circle at 35% 35%, #fff, #ccc); border-color: rgba(0,0,0,0.2); }
    .turn-indicator.black { background: radial-gradient(circle at 35% 35%, #555, #1a1a1a); }

    /* ── Board Area ───────────────────────────────── */
    .board-area {
      display: flex; align-items: stretch; justify-content: center;
      flex: 1; width: 100%;
      min-height: 0; gap: 0; padding: 4px 0;
    }
    .board-wrapper {
      position: relative;
      display: flex; align-items: center; justify-content: center;
      flex: 1; min-width: 0; min-height: 0;
      height: 100%; max-height: 100%;
    }
    .board {
      position: relative;
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      grid-template-rows: auto 1fr 1fr auto;
      background: linear-gradient(135deg, #2c2c3a 0%, #33334a 50%, #2c2c3a 100%);
      border: 4px solid #c9a96e;
      border-radius: 12px;
      overflow: hidden;
      /* Size set by JS fitBoard() for reliable contain-fit */
      box-shadow: 0 4px 20px rgba(0,0,0,0.4), inset 0 0 40px rgba(0,0,0,0.1);
    }

    /* Point number rows */
    .point-labels {
      grid-column: 1 / -1; display: grid;
      grid-template-columns: 1fr auto 1fr; height: 16px;
    }
    .point-labels-half { display: flex; }
    .point-labels .bar-spacer { width: 36px; }
    .point-label {
      flex: 1; text-align: center;
      font-size: 0.52rem; color: rgba(255, 255, 255, 0.3); line-height: 16px;
    }

    /* Quadrants */
    .quadrant { display: flex; padding: 2px 2px; align-items: stretch; min-height: 0; }
    .quadrant.top-left, .quadrant.bottom-left { grid-column: 1; }
    .quadrant.top-right, .quadrant.bottom-right { grid-column: 3; }
    .quadrant.top-left { grid-row: 2; }
    .quadrant.top-right { grid-row: 2; }
    .quadrant.bottom-left { grid-row: 3; }
    .quadrant.bottom-right { grid-row: 3; }

    /* Bar */
    .bar {
      grid-column: 2; grid-row: 2 / 4; width: 36px;
      background: linear-gradient(180deg, #3d3522 0%, #4a4030 50%, #3d3522 100%);
      border-left: 2px solid #c9a96e; border-right: 2px solid #c9a96e;
      display: flex; flex-direction: column; justify-content: space-between;
      align-items: center; padding: 4px 0; cursor: default;
    }
    .bar-checkers { display: flex; flex-direction: column; align-items: center; gap: 0px; }
    .bar.selectable { cursor: pointer; }
    .bar.selectable .bar-checkers.active-bar .checker:last-child { box-shadow: 0 0 6px 3px rgba(255, 200, 0, 0.7); cursor: pointer; }
    .bar.selected .bar-checkers.active-bar .checker:last-child { box-shadow: 0 0 10px 4px rgba(80, 255, 120, 0.75); }

    /* ── Points (triangles) ──────────────────────── */
    .point {
      flex: 1; display: flex; flex-direction: column; align-items: center;
      position: relative; min-width: 0; cursor: default;
    }
    .quadrant.bottom .point { flex-direction: column-reverse; }

    .point .triangle {
      position: absolute; width: 100%; height: 82%;
      clip-path: polygon(0 0, 100% 0, 50% 100%); transition: filter 0.15s;
    }
    .quadrant.bottom .point .triangle { clip-path: polygon(50% 0, 0 100%, 100% 100%); bottom: 0; }
    .quadrant.top .point .triangle { top: 0; }

    /* Wood-grain triangle gradients */
    .point.dark .triangle {
      background: linear-gradient(170deg, #5c3d2e 0%, #6b4a38 25%, #5c3d2e 50%, #4d3225 75%, #5c3d2e 100%);
    }
    .point.light .triangle {
      background: linear-gradient(170deg, #c9a96e 0%, #d4b87a 25%, #c9a96e 50%, #b89858 75%, #c9a96e 100%);
    }

    /* ── Interaction Highlights ───────────────────── */
    .point.selectable { cursor: pointer; }
    .point.selectable .checkers .checker:last-child { box-shadow: 0 0 6px 3px rgba(255, 200, 0, 0.7); cursor: pointer; }
    .point.selected .checkers .checker:last-child { box-shadow: 0 0 10px 4px rgba(80, 255, 120, 0.75); }
    .point.valid-target { cursor: pointer; }
    .point.valid-target .triangle { filter: brightness(1.6) saturate(1.3); }
    .point.valid-target::after {
      content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0;
      border: 2px solid rgba(80, 255, 120, 0.5); border-radius: 3px; z-index: 2; pointer-events: none;
    }
    .point.combined-target { cursor: pointer; }
    .point.combined-target .triangle { filter: brightness(1.4) saturate(1.1); }
    .point.combined-target::after {
      content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0;
      border: 2px dashed rgba(200, 180, 80, 0.6); border-radius: 3px; z-index: 2; pointer-events: none;
    }

    /* ── Checkers (3D Glossy) ────────────────────── */
    .checkers {
      display: flex; flex-direction: column; align-items: center;
      z-index: 1; gap: 0px; max-height: 100%;
    }
    .quadrant.bottom .checkers { flex-direction: column-reverse; }

    .checker {
      width: 44px; height: 44px;
      border-radius: 50%; flex-shrink: 0; position: relative;
      transition: box-shadow 0.15s;
    }
    .checker.white {
      background: radial-gradient(circle at 35% 30%, #FFFFFF 0%, #E8E8E8 40%, #A0A0A0 100%);
      border: 2px solid rgba(0, 0, 0, 0.15);
      box-shadow: 0 2px 4px rgba(0,0,0,0.25), 0 4px 8px rgba(0,0,0,0.12), inset 0 0 0 2px rgba(255,255,255,0.15);
    }
    .checker.black {
      background: radial-gradient(circle at 35% 30%, #555555 0%, #2A2A2A 40%, #000000 100%);
      border: 2px solid rgba(255, 255, 255, 0.15);
      box-shadow: 0 2px 4px rgba(0,0,0,0.35), 0 4px 8px rgba(0,0,0,0.2), inset 0 0 0 2px rgba(255,255,255,0.08);
    }

    /* Bar checkers (smaller) */
    .bar-checkers .checker { width: 30px; height: 30px; }

    /* ── Checker Animation Overlay ──────────────── */
    .anim-checker {
      position: fixed; width: 30px; height: 30px; border-radius: 50%;
      pointer-events: none; z-index: 9999; transition: none;
      box-shadow: 0 2px 8px rgba(0,0,0,0.5);
    }
    .anim-checker.white {
      background: radial-gradient(circle at 35% 30%, #FFFFFF 0%, #E8E8E8 40%, #A0A0A0 100%);
      border: 2px solid rgba(0,0,0,0.15);
    }
    .anim-checker.black {
      background: radial-gradient(circle at 35% 30%, #555555 0%, #2A2A2A 40%, #000000 100%);
      border: 2px solid rgba(255,255,255,0.15);
    }
    .anim-checker.animating {
      transition: left 0.35s cubic-bezier(0.25, 0.1, 0.25, 1),
                  top 0.35s cubic-bezier(0.25, 0.1, 0.25, 1), opacity 0.35s ease;
    }
    .anim-checker.bear-off {
      transition: left 0.35s cubic-bezier(0.25, 0.1, 0.25, 1),
                  top 0.35s cubic-bezier(0.25, 0.1, 0.25, 1),
                  opacity 0.35s ease, transform 0.35s ease;
    }

    /* ── Dice ON Board ───────────────────────────── */
    .board-dice-overlay {
      position: absolute;
      top: 50%; right: 10%;
      transform: translateY(-50%);
      display: flex; gap: 10px; z-index: 10;
      pointer-events: none;
    }
    .board-dice-overlay .die { pointer-events: auto; }

    .die {
      width: 52px; height: 52px;
      background: #F5F0E1; border-radius: 10px;
      display: flex; align-items: center; justify-content: center;
      box-shadow: 0 4px 10px rgba(0,0,0,0.45), inset 0 2px 0 rgba(255,255,255,0.5), inset 0 -2px 4px rgba(0,0,0,0.12);
      position: relative; transition: opacity 0.3s, transform 0.3s;
    }
    .die.rolling { animation: roll 0.4s ease-out; }
    .die.used { opacity: 0.25; }
    .die.used::after {
      content: ''; position: absolute; top: 50%; left: 8px; right: 8px;
      height: 3px; background: #e74c3c; transform: rotate(-45deg); border-radius: 2px;
    }
    .doubles-badge {
      position: absolute; top: -6px; right: -6px;
      background: #c9a96e; color: #1a1a2e;
      font-size: 0.6rem; font-weight: 700; width: 16px; height: 16px;
      border-radius: 50%; display: flex; align-items: center; justify-content: center; z-index: 3;
    }

    @keyframes roll {
      0%   { transform: rotate(0deg) scale(1); }
      25%  { transform: rotate(90deg) scale(0.9); }
      50%  { transform: rotate(180deg) scale(1.05); }
      75%  { transform: rotate(270deg) scale(0.95); }
      100% { transform: rotate(360deg) scale(1); }
    }

    .die-face { width: 36px; height: 36px; position: relative; }
    .pip {
      width: 8px; height: 8px; background: #333; border-radius: 50%;
      position: absolute; box-shadow: inset 0 1px 2px rgba(0,0,0,0.3);
    }
    .pip.tl { top: 2px; left: 2px; } .pip.tc { top: 2px; left: 50%; transform: translateX(-50%); }
    .pip.tr { top: 2px; right: 2px; } .pip.ml { top: 50%; left: 2px; transform: translateY(-50%); }
    .pip.mc { top: 50%; left: 50%; transform: translate(-50%,-50%); }
    .pip.mr { top: 50%; right: 2px; transform: translateY(-50%); }
    .pip.bl { bottom: 2px; left: 2px; } .pip.bc { bottom: 2px; left: 50%; transform: translateX(-50%); }
    .pip.br { bottom: 2px; right: 2px; }

    /* ── Cube Display (centered on bar, in board-wrapper) ── */
    .cube-display {
      display: none; align-items: center; justify-content: center;
      position: absolute; left: 50%; top: 50%;
      transform: translate(-50%, -50%);
      z-index: 15; pointer-events: none;
    }
    .cube-display.visible { display: flex; }
    .cube-display.owner-white { top: auto; bottom: 12%; transform: translate(-50%, 0); }
    .cube-display.owner-black { top: 12%; bottom: auto; transform: translate(-50%, 0); }
    .cube-visual {
      width: 40px; height: 40px; background: #1e1e30;
      border: 2px solid #c9a96e; border-radius: 6px;
      display: flex; align-items: center; justify-content: center;
      font-size: 1rem; font-weight: 800; color: #c9a96e;
      box-shadow: 0 2px 8px rgba(0,0,0,0.5), inset 0 1px 0 rgba(255,255,255,0.05);
    }
    .cube-owner-label { display: none; }

    /* ── Bear-Off Trays (inside board corners) ───── */
    .bear-off-tray {
      width: 44px;
      min-width: 44px;
      background: #232336;
      border: 2px solid #c9a96e;
      border-radius: 8px;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 6px 2px;
      gap: 2px;
      transition: box-shadow 0.2s, border-color 0.2s;
    }
    .bear-off-tray.left { margin-right: 6px; }
    .bear-off-tray.right { margin-left: 6px; }
    .bear-off-tray .tray-label {
      font-size: 0.55rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: rgba(255, 255, 255, 0.35);
      margin-bottom: 2px;
    }
    .bear-off-tray .tray-count {
      font-size: 0.85rem;
      font-weight: 700;
      color: #c9a96e;
      margin-bottom: 4px;
    }
    .bear-off-tray .tray-checkers {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1px;
      flex: 1;
      overflow: hidden;
    }
    .bear-off-tray .checker {
      width: 28px;
      height: 28px;
    }
    .bear-off-tray.valid-target {
      border-color: rgba(80, 255, 120, 0.7);
      box-shadow: 0 0 12px 3px rgba(80, 255, 120, 0.3);
      cursor: pointer;
    }

    /* ── Bottom Bar ──────────────────────────────── */
    .bottom-bar {
      display: flex; align-items: center; justify-content: center;
      gap: 12px; width: 100%; max-width: 960px;
      height: 48px; flex-shrink: 0; padding: 0 13px;
    }
    .bottom-bar .icon-btn {
      width: 40px; height: 40px; border-radius: 8px; border: none;
      background: transparent; cursor: pointer;
      display: flex; align-items: center; justify-content: center; padding: 0;
      transition: background 0.2s, transform 0.1s;
      position: relative;
    }
    .bottom-bar .icon-btn:hover { background: rgba(255,255,255,0.08); }
    .bottom-bar .icon-btn:active { transform: scale(0.92); }
    .bottom-bar .icon-btn svg { width: 28px; height: 28px; }
    .bottom-bar .icon-btn.hidden { display: none; }

    .undo-btn svg { fill: #e07050; }
    .surrender-btn svg { fill: #a05050; }

    .bottom-bar-toggles {
      display: flex; align-items: center; gap: 6px;
    }
    .icon-toggle {
      width: 40px; height: 40px; display: flex; align-items: center; justify-content: center;
      cursor: pointer; border-radius: 8px;
      transition: background 0.2s;
      position: relative;
    }
    .icon-toggle:hover { background: rgba(255,255,255,0.06); }
    .icon-toggle input { display: none; }
    .icon-toggle svg { width: 28px; height: 28px; fill: rgba(255,255,255,0.25); transition: fill 0.2s; }
    .icon-toggle.active svg { fill: #c9a96e; }

    /* ── Bottom Bar Tooltips ────────────────────────── */
    .bottom-bar [data-tooltip] { position: relative; }
    .bottom-bar [data-tooltip]::after {
      content: attr(data-tooltip);
      position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%);
      margin-bottom: 6px; padding: 4px 10px;
      background: rgba(20, 20, 30, 0.92); color: #fff;
      font-size: 0.7rem; font-weight: 500; letter-spacing: 0.02em;
      white-space: nowrap; border-radius: 20px;
      pointer-events: none; opacity: 0;
      transition: opacity 0.2s ease 0.2s;
    }
    .bottom-bar [data-tooltip]:hover::after { opacity: 1; }

    .roll-btn {
      padding: 10px 28px; font-size: 0.92rem; font-weight: 600;
      letter-spacing: 0.05em; background: #c9a96e; color: #1a1a2e;
      border: none; border-radius: 8px; cursor: pointer;
      transition: background 0.2s, transform 0.1s; user-select: none; font-family: inherit;
    }
    .roll-btn:hover { background: #dfc08a; }
    .roll-btn:active { transform: scale(0.96); }
    .roll-btn:disabled { opacity: 0.4; cursor: default; }
    .roll-btn.hidden { display: none; }

    .double-btn {
      padding: 8px 16px; font-size: 0.82rem; font-weight: 600; letter-spacing: 0.03em;
      background: transparent; color: #c9a96e; border: 2px solid #c9a96e;
      border-radius: 8px; cursor: pointer; transition: background 0.2s, transform 0.1s;
      user-select: none; font-family: inherit;
    }
    .double-btn:hover { background: rgba(201, 169, 110, 0.15); }
    .double-btn:active { transform: scale(0.96); }
    .double-btn.hidden { display: none; }

    /* Hidden shell elements (for JS compatibility) */
    .controls.hidden { display: none; }
    .scoreboard { display: none; }
    .toggle-row { display: none; }
    .toggle-row.visible { display: none; }

    /* ═══════════════════════════════════════════════
       OVERLAYS
       ═══════════════════════════════════════════════ */

    /* ── Doubling Overlay ────────────────────────── */
    .doubling-overlay {
      position: fixed; top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(10, 10, 20, 0.7);
      backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
      z-index: 900; display: none; flex-direction: column;
      align-items: center; justify-content: center; gap: 16px;
    }
    .doubling-overlay.visible { display: flex; }
    .doubling-overlay .overlay-content {
      background: #2c2c3a; border: 2px solid #c9a96e; border-radius: 12px;
      padding: 28px 36px; text-align: center; max-width: 380px;
    }
    .doubling-overlay .overlay-title { font-size: 1.15rem; font-weight: 700; color: #c9a96e; margin-bottom: 8px; }
    .doubling-overlay .overlay-text { font-size: 0.92rem; color: #e0e0e0; margin-bottom: 20px; line-height: 1.5; }
    .doubling-overlay .overlay-cube {
      width: 52px; height: 52px; background: #2c2c3a; border: 3px solid #c9a96e; border-radius: 8px;
      display: flex; align-items: center; justify-content: center;
      font-size: 1.4rem; font-weight: 800; color: #c9a96e;
      margin: 0 auto 18px; box-shadow: 0 3px 12px rgba(0,0,0,0.4);
    }
    .doubling-overlay .overlay-buttons { display: flex; gap: 12px; justify-content: center; }
    .doubling-overlay .accept-btn {
      padding: 10px 24px; font-size: 0.92rem; font-weight: 600;
      background: #3a8b4a; color: #fff; border: none; border-radius: 8px;
      cursor: pointer; transition: background 0.2s, transform 0.1s; font-family: inherit;
    }
    .doubling-overlay .accept-btn:hover { background: #4a9b5a; }
    .doubling-overlay .decline-btn {
      padding: 10px 24px; font-size: 0.92rem; font-weight: 600;
      background: #8b3a3a; color: #fff; border: none; border-radius: 8px;
      cursor: pointer; transition: background 0.2s, transform 0.1s; font-family: inherit;
    }
    .doubling-overlay .decline-btn:hover { background: #9b4a4a; }

    /* ── Surrender Overlay ────────────────────────── */
    .surrender-overlay {
      position: fixed; top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(10, 10, 20, 0.7);
      backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
      z-index: 900; display: none; flex-direction: column;
      align-items: center; justify-content: center;
    }
    .surrender-overlay.visible { display: flex; }
    .surrender-overlay .overlay-content {
      background: #2c2c3a; border: 2px solid #a05050; border-radius: 12px;
      padding: 28px 36px; text-align: center; max-width: 360px;
    }
    .surrender-overlay .overlay-title { font-size: 1.05rem; font-weight: 700; color: #e07050; margin-bottom: 12px; }
    .surrender-overlay .overlay-text { font-size: 0.9rem; color: #e0e0e0; margin-bottom: 20px; line-height: 1.5; }
    .surrender-overlay .overlay-buttons { display: flex; gap: 12px; justify-content: center; }
    .surrender-overlay .confirm-btn {
      padding: 10px 24px; font-size: 0.92rem; font-weight: 600;
      background: #8b3a3a; color: #fff; border: none; border-radius: 8px;
      cursor: pointer; transition: background 0.2s, transform 0.1s; font-family: inherit;
    }
    .surrender-overlay .confirm-btn:hover { background: #9b4a4a; }
    .surrender-overlay .cancel-btn {
      padding: 10px 24px; font-size: 0.92rem; font-weight: 600;
      background: rgba(255,255,255,0.1); color: #e0e0e0; border: none; border-radius: 8px;
      cursor: pointer; transition: background 0.2s, transform 0.1s; font-family: inherit;
    }
    .surrender-overlay .cancel-btn:hover { background: rgba(255,255,255,0.18); }

    /* ── Win Overlay ─────────────────────────────── */
    .win-overlay {
      position: fixed; top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(10, 10, 20, 0.88);
      backdrop-filter: blur(6px); -webkit-backdrop-filter: blur(6px);
      z-index: 1000; display: none; flex-direction: column;
      align-items: center; justify-content: center;
      opacity: 0; transition: opacity 0.6s ease;
    }
    .win-overlay.visible { display: flex; }
    .win-overlay.fade-in { opacity: 1; }
    .win-overlay canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }

    .win-content {
      position: relative; z-index: 1; text-align: center;
      display: flex; flex-direction: column; align-items: center; gap: 12px;
    }
    .win-trophy { font-size: 4rem; animation: trophy-bounce 1s ease-out; }
    @keyframes trophy-bounce {
      0%   { transform: scale(0) rotate(-20deg); opacity: 0; }
      50%  { transform: scale(1.3) rotate(5deg); opacity: 1; }
      70%  { transform: scale(0.9) rotate(-3deg); }
      100% { transform: scale(1) rotate(0deg); }
    }

    .winner-text {
      font-size: 3.5rem; font-weight: 800;
      letter-spacing: 0.06em; text-transform: uppercase;
      background: linear-gradient(135deg, #c9a96e, #e8d5a3, #c9a96e);
      -webkit-background-clip: text; -webkit-text-fill-color: transparent;
      background-clip: text;
      animation: glow-pulse 2s ease-in-out infinite;
    }
    .winner-text.white-wins {
      background: linear-gradient(135deg, #ffffff, #e8d5a3, #ffffff);
      -webkit-background-clip: text; background-clip: text;
      filter: drop-shadow(0 0 20px rgba(255,255,255,0.4));
    }
    .winner-text.black-wins {
      background: linear-gradient(135deg, #888888, #c9a96e, #888888);
      -webkit-background-clip: text; background-clip: text;
      filter: drop-shadow(0 0 20px rgba(180,180,180,0.3));
    }
    @keyframes glow-pulse {
      0%, 100% { filter: brightness(1); transform: scale(1); }
      50%      { filter: brightness(1.2); transform: scale(1.02); }
    }

    .win-subtitle {
      font-size: 1.2rem; font-weight: 300;
      color: #c9a96e; letter-spacing: 0.08em;
      opacity: 0; animation: subtitle-appear 0.8s ease 0.5s forwards;
    }
    @keyframes subtitle-appear {
      from { opacity: 0; transform: translateY(10px); }
      to   { opacity: 1; transform: translateY(0); }
    }
    .win-type-label {
      font-size: 1.05rem; font-weight: 700;
      text-transform: uppercase; letter-spacing: 0.1em;
      opacity: 0; animation: subtitle-appear 0.6s ease 0.7s forwards;
    }
    .win-type-label.normal { color: #8ca96e; }
    .win-type-label.gammon { color: #e0a040; }
    .win-type-label.backgammon { color: #e05050; }

    .win-points-info {
      font-size: 0.95rem; font-weight: 600;
      color: rgba(255,255,255,0.7);
      opacity: 0; animation: subtitle-appear 0.6s ease 0.9s forwards;
    }

    .play-again-btn {
      margin-top: 12px; padding: 13px 38px; font-size: 1.05rem; font-weight: 700;
      letter-spacing: 0.06em; text-transform: uppercase;
      background: linear-gradient(135deg, #c9a96e, #e8d5a3); color: #1a1a2e;
      border: none; border-radius: 10px; cursor: pointer;
      transition: transform 0.15s, box-shadow 0.2s; user-select: none; font-family: inherit;
      opacity: 0; animation: btn-appear 0.6s ease 1s forwards;
      box-shadow: 0 4px 16px rgba(201, 169, 110, 0.3);
    }
    .play-again-btn:hover { transform: scale(1.04); box-shadow: 0 6px 20px rgba(201, 169, 110, 0.45); }
    .play-again-btn:active { transform: scale(0.97); }

    .new-match-btn {
      padding: 10px 24px; font-size: 0.82rem; font-weight: 600;
      letter-spacing: 0.04em; text-transform: uppercase;
      background: transparent; color: rgba(255,255,255,0.5);
      border: 1px solid rgba(255,255,255,0.2); border-radius: 8px;
      cursor: pointer; transition: background 0.2s, color 0.2s, transform 0.15s;
      user-select: none; font-family: inherit;
      opacity: 0; animation: btn-appear 0.6s ease 1.2s forwards;
    }
    .new-match-btn:hover { background: rgba(255,255,255,0.08); color: rgba(255,255,255,0.7); }
    .new-match-btn:active { transform: scale(0.97); }

    @keyframes btn-appear {
      from { opacity: 0; transform: translateY(15px); }
      to   { opacity: 1; transform: translateY(0); }
    }

    /* Board blur when win overlay is active */
    body.win-active .board-area { filter: blur(4px); transition: filter 0.4s; }
  </style>
</head>
<body>

  <div id="game-root">

  <!-- ═══ SETUP SCREEN ═══ -->
  <div id="setupScreen" class="screen setup-screen">
    <h1>Backgammon</h1>
    <div class="setup-card">
      <div class="mode-select" id="modeSelect">
        <div class="mode-buttons">
          <button class="mode-btn active" id="btnPvP">Player vs Player</button>
          <button class="mode-btn" id="btnPvAI">Player vs AI</button>
        </div>

        <!-- Avatar Pickers + Name Inputs -->
        <div class="player-name-inputs" id="playerNameInputs">
          <div class="name-field">
            <label><span class="name-dot white"></span>Player 1 (White)</label>
            <div class="avatar-picker-grid" id="avatarPickerWhite">
              <button type="button" class="avatar-option selected" data-icon="crown" title="Crown"><svg viewBox="0 0 24 24"><path d="M3 18h18v2H3v-2zm-.5-2L6 8l4.5 4L12 4l1.5 8L18 8l3.5 8H2.5z"/></svg></button>
              <button type="button" class="avatar-option" data-icon="sword" title="Sword"><svg viewBox="0 0 24 24"><path d="M14.12 4l1.83 1.83-6.19 6.18-2.83-2.83L14.12 4M17.5 2l-8.49 8.49 3.54 3.54L21 5.59V2h-3.5zM2 19.59l3.17-3.17 3.54 3.54L5.54 23.13 2 19.59z"/></svg></button>
              <button type="button" class="avatar-option" data-icon="shield" title="Shield"><svg viewBox="0 0 24 24"><path d="M12 1L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4z"/></svg></button>
              <button type="button" class="avatar-option" data-icon="star" title="Star"><svg viewBox="0 0 24 24"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87L18.18 22 12 18.27 5.82 22 7 14.14l-5-4.87 6.91-1.01L12 2z"/></svg></button>
              <button type="button" class="avatar-option" data-icon="flame" title="Flame"><svg viewBox="0 0 24 24"><path d="M12 23c-4.97 0-9-3.58-9-8 0-3.07 2.13-5.83 4-7.41V6c0-3.31 2.69-6 6-6 .34 0 .67.03 1 .08C12.7 1.43 12 3.15 12 5c0 3.31 2.69 6 6 6 .34 0 .67-.03 1-.08-.26 4.46-3.5 8.71-7 12.08z"/></svg></button>
              <button type="button" class="avatar-option" data-icon="knight" title="Knight"><svg viewBox="0 0 24 24"><path d="M19 22H5v-2h14v2M13 2c-1.25 0-2.42.62-3.11 1.66L7 8l2 2-3 5h2l3-4.5 1 .5V18h4V9l2-4c.39-.78.39-1.72 0-2.5C17.61 1.4 15.78.65 14 2h-1z"/></svg></button>
              <button type="button" class="avatar-option" data-icon="lightning" title="Lightning"><svg viewBox="0 0 24 24"><path d="M7 2v11h3v9l7-12h-4l4-8H7z"/></svg></button>
              <button type="button" class="avatar-option" data-icon="diamond" title="Diamond"><svg viewBox="0 0 24 24"><path d="M12 2L2 12l10 10 10-10L12 2zm0 3l7 7-7 7-7-7 7-7z"/></svg></button>
            </div>
            <input type="text" id="player1Name" placeholder="White" maxlength="16">
          </div>
          <div class="name-field" id="player2Field">
            <label><span class="name-dot black"></span>Player 2 (Black)</label>
            <div class="avatar-picker-grid" id="avatarPickerBlack">
              <button type="button" class="avatar-option" data-icon="crown" title="Crown"><svg viewBox="0 0 24 24"><path d="M3 18h18v2H3v-2zm-.5-2L6 8l4.5 4L12 4l1.5 8L18 8l3.5 8H2.5z"/></svg></button>
              <button type="button" class="avatar-option" data-icon="sword" title="Sword"><svg viewBox="0 0 24 24"><path d="M14.12 4l1.83 1.83-6.19 6.18-2.83-2.83L14.12 4M17.5 2l-8.49 8.49 3.54 3.54L21 5.59V2h-3.5zM2 19.59l3.17-3.17 3.54 3.54L5.54 23.13 2 19.59z"/></svg></button>
              <button type="button" class="avatar-option selected" data-icon="shield" title="Shield"><svg viewBox="0 0 24 24"><path d="M12 1L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4z"/></svg></button>
              <button type="button" class="avatar-option" data-icon="star" title="Star"><svg viewBox="0 0 24 24"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87L18.18 22 12 18.27 5.82 22 7 14.14l-5-4.87 6.91-1.01L12 2z"/></svg></button>
              <button type="button" class="avatar-option" data-icon="flame" title="Flame"><svg viewBox="0 0 24 24"><path d="M12 23c-4.97 0-9-3.58-9-8 0-3.07 2.13-5.83 4-7.41V6c0-3.31 2.69-6 6-6 .34 0 .67.03 1 .08C12.7 1.43 12 3.15 12 5c0 3.31 2.69 6 6 6 .34 0 .67-.03 1-.08-.26 4.46-3.5 8.71-7 12.08z"/></svg></button>
              <button type="button" class="avatar-option" data-icon="knight" title="Knight"><svg viewBox="0 0 24 24"><path d="M19 22H5v-2h14v2M13 2c-1.25 0-2.42.62-3.11 1.66L7 8l2 2-3 5h2l3-4.5 1 .5V18h4V9l2-4c.39-.78.39-1.72 0-2.5C17.61 1.4 15.78.65 14 2h-1z"/></svg></button>
              <button type="button" class="avatar-option" data-icon="lightning" title="Lightning"><svg viewBox="0 0 24 24"><path d="M7 2v11h3v9l7-12h-4l4-8H7z"/></svg></button>
              <button type="button" class="avatar-option" data-icon="diamond" title="Diamond"><svg viewBox="0 0 24 24"><path d="M12 2L2 12l10 10 10-10L12 2zm0 3l7 7-7 7-7-7 7-7z"/></svg></button>
            </div>
            <input type="text" id="player2Name" placeholder="Black" maxlength="16">
          </div>
        </div>

        <div class="settings-area" id="settingsArea">
          <div class="ai-settings" id="aiSettings">
            <span class="ai-label">AI Difficulty</span>
            <div class="ai-difficulty-btns">
              <button class="ai-diff-btn" data-diff="beginner">Beginner</button>
              <button class="ai-diff-btn selected" data-diff="intermediate">Intermediate</button>
              <button class="ai-diff-btn" data-diff="advanced">Professional</button>
            </div>
          </div>
        </div>

        <div class="cube-settings">
          <span class="cube-settings-label">Doubling Cube</span>
          <label class="toggle-switch">
            <input type="checkbox" id="cubeToggle">
            <span class="toggle-track"></span>
            <span class="toggle-knob"></span>
          </label>
          <div class="cube-max-wrapper" id="cubeMaxWrapper">
            <label>Max</label>
            <select class="cube-max-select" id="cubeMaxSelect">
              <option value="2">2</option>
              <option value="4">4</option>
              <option value="8">8</option>
              <option value="16">16</option>
              <option value="32">32</option>
              <option value="64" selected>64</option>
            </select>
          </div>
        </div>

        <button class="start-game-btn" id="btnStartGame">START GAME</button>
      </div>
    </div>
  </div>

  <!-- ═══ GAME SCREEN ═══ -->
  <div id="gameScreen" class="screen game-screen hidden removed">

    <!-- Top Bar -->
    <div class="top-bar" id="topBar">
      <div class="top-bar-player left" id="topBarP1">
        <div class="top-bar-avatar" id="topBarAvatarP1"></div>
        <span class="top-bar-name" id="topBarNameP1">White</span>
        <span class="top-bar-score" id="scoreWhite">0</span>
        <span id="scoreWhiteName" class="sr-only">White</span>
      </div>
      <div class="top-bar-center">
        <div class="status-area" id="statusArea">
          <div class="status-bar" id="statusBar">Choose a game mode to begin.</div>
          <div class="ai-thinking-line" id="aiThinking">
            AI is thinking
            <div class="ai-thinking-dots"><span></span><span></span><span></span></div>
          </div>
        </div>
      </div>
      <div class="top-bar-player right" id="topBarP2">
        <span class="top-bar-score" id="scoreBlack">0</span>
        <span id="scoreBlackName" class="sr-only">Black</span>
        <span class="top-bar-name" id="topBarNameP2">Black</span>
        <div class="top-bar-avatar" id="topBarAvatarP2"></div>
      </div>
    </div>

    <!-- Board Area -->
    <div class="board-area">
      <!-- Bear-Off Tray: Black (left side) -->
      <div class="bear-off-tray left" id="trayBlack">
        <div class="tray-label">OFF</div>
        <div class="tray-count" id="trayBlackCount">0</div>
        <div class="tray-checkers" id="trayBlackCheckers"></div>
      </div>
      <div class="board-wrapper">
        <div class="board" id="board"></div>
        <!-- Dice ON the board -->
        <div class="board-dice-overlay" id="diceContainer">
          <div class="die" id="die1"><div class="die-face" id="dieFace1"></div></div>
          <div class="die" id="die2"><div class="die-face" id="dieFace2"></div></div>
        </div>
        <!-- Cube Display (on board) -->
        <div class="cube-display" id="cubeDisplay">
          <div class="cube-visual" id="cubeValue">1</div>
          <span class="cube-owner-label" id="cubeOwnerLabel">Center</span>
        </div>
      </div>
      <!-- Bear-Off Tray: White (right side) -->
      <div class="bear-off-tray right" id="trayWhite">
        <div class="tray-label">OFF</div>
        <div class="tray-count" id="trayWhiteCount">0</div>
        <div class="tray-checkers" id="trayWhiteCheckers"></div>
      </div>
    </div>

    <!-- Bottom Bar -->
    <div class="bottom-bar" id="bottomBar">
      <button class="icon-btn undo-btn hidden" id="undoBtn" title="Undo" data-tooltip="Undo">
        <svg viewBox="0 0 24 24"><path d="M12.5 8c-2.65 0-5.05.99-6.9 2.6L2 7v9h9l-3.62-3.62c1.39-1.16 3.16-1.88 5.12-1.88 3.54 0 6.55 2.31 7.6 5.5l2.37-.78C21.08 11.03 17.15 8 12.5 8z"/></svg>
      </button>
      <div class="bottom-bar-toggles">
        <label class="icon-toggle" id="autoRollIconToggle" title="Auto Roll" data-tooltip="Auto Roll">
          <input type="checkbox" id="autoRollToggle">
          <svg viewBox="0 0 24 24"><path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-7 14c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zm4-8c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zM8 11c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2z"/></svg>
        </label>
        <label class="icon-toggle active" id="soundIconToggle" title="Sound" data-tooltip="Sound">
          <input type="checkbox" id="soundToggle" checked>
          <svg viewBox="0 0 24 24"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/></svg>
        </label>
      </div>
      <button class="roll-btn" id="rollBtn">Roll Dice</button>
      <button class="double-btn hidden" id="doubleBtn">Double</button>
      <button class="icon-btn surrender-btn hidden" id="surrenderBtn" title="Surrender" data-tooltip="Surrender">
        <svg viewBox="0 0 24 24"><path d="M14.4 6L14 4H5v17h2v-7h5.6l.4 2h7V6h-5.6z"/></svg>
      </button>
    </div>

    <!-- Hidden shell elements for JS compatibility -->
    <div class="scoreboard" id="scoreboard"></div>
    <div class="controls hidden" id="controls"></div>
    <div class="toggle-row" id="toggleRow"></div>
  </div>

  <!-- ═══ OVERLAYS ═══ -->
  <div class="doubling-overlay" id="doublingOverlay">
    <div class="overlay-content">
      <div class="overlay-title" id="doublingTitle">Double Offered!</div>
      <div class="overlay-text" id="doublingText"></div>
      <div class="overlay-cube" id="doublingCubeValue"></div>
      <div class="overlay-buttons">
        <button class="accept-btn" id="acceptDoubleBtn">Accept</button>
        <button class="decline-btn" id="declineDoubleBtn">Decline</button>
      </div>
    </div>
  </div>

  <div class="surrender-overlay" id="surrenderOverlay">
    <div class="overlay-content">
      <div class="overlay-title">Surrender?</div>
      <div class="overlay-text" id="surrenderText"></div>
      <div class="overlay-buttons">
        <button class="confirm-btn" id="confirmSurrenderBtn">Yes, Surrender</button>
        <button class="cancel-btn" id="cancelSurrenderBtn">Cancel</button>
      </div>
    </div>
  </div>

  <div class="win-overlay" id="winOverlay">
    <canvas id="confettiCanvas"></canvas>
    <div class="win-content">
      <div class="win-trophy">&#127942;</div>
      <div class="winner-text" id="winnerText"></div>
      <div class="win-type-label" id="winTypeLabel"></div>
      <div class="win-points-info" id="winPointsInfo"></div>
      <div class="win-subtitle">Congratulations! Outstanding game!</div>
      <button class="play-again-btn" id="playAgainBtn">Play Again</button>
      <button class="new-match-btn" id="newMatchBtn">New Match</button>
    </div>
  </div>

  </div><!-- end #game-root -->

  <script>
    // ════════════════════════════════════════════════
    //  CONSTANTS
    // ════════════════════════════════════════════════

    const STARTING_POSITION = {
      1:   2,   // 2 white
      6:  -5,   // 5 black
      8:  -3,   // 3 black
      12:  5,   // 5 white
      13: -5,   // 5 black
      17:  3,   // 3 white
      19:  5,   // 5 white
      24: -2    // 2 black
    };

    const PIP_LAYOUTS = {
      1: ['mc'],
      2: ['tr', 'bl'],
      3: ['tr', 'mc', 'bl'],
      4: ['tl', 'tr', 'bl', 'br'],
      5: ['tl', 'tr', 'mc', 'bl', 'br'],
      6: ['tl', 'ml', 'bl', 'tr', 'mr', 'br'],
    };

    const Phase = {
      MODE_SELECT:  'MODE_SELECT',
      OPENING_ROLL: 'OPENING_ROLL',
      ROLLING:      'ROLLING',
      MOVING:       'MOVING',
      DOUBLING:     'DOUBLING',
      GAME_OVER:    'GAME_OVER',
    };

    const GRACE_PERIOD_MS = 3000;

    // ════════════════════════════════════════════════
    //  GAME STATE
    // ════════════════════════════════════════════════

    const G = {
      phase: Phase.MODE_SELECT,
      mode: null,            // 'pvp' | 'pvai'

      board: new Array(26).fill(0),

      currentPlayer: 'white',  // 'white' | 'black'

      dice: {
        values: [],      // original roll, e.g. [3,5] or [4,4]
        remaining: [],   // die values still usable
      },

      selectedPoint: null,
      validMoves: [],
      combinedTargets: [],
      allLegalMoves: [],
      message: '',

      undoStack: [],

      borneOff: { white: 0, black: 0 },

      autoRoll: false,
      soundEnabled: true,

      // Scoring (persists across games within a session)
      score: { white: 0, black: 0 },

      // Doubling cube
      cube: {
        value: 1,
        owner: null,        // null = centered, 'white' or 'black'
        enabled: false,
        maxValue: 64,
      },

      // Grace period timer
      graceTimer: null,

      // Who is being asked to accept a double
      doublingTarget: null,

      // Player names
      playerNames: { white: 'White', black: 'Black' },

      // AI settings
      aiDifficulty: 'intermediate', // 'beginner' | 'intermediate' | 'advanced'
      aiThinking: false,
      aiTimers: [],  // track timeouts so they can be cancelled
    };

    // ════════════════════════════════════════════════
    //  SOUND — Web Audio API (programmatic)
    // ════════════════════════════════════════════════

    let audioCtx = null;

    function getAudioCtx() {
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }
      if (audioCtx.state === 'suspended') {
        audioCtx.resume();
      }
      return audioCtx;
    }

    function playMoveSound() {
      if (!G.soundEnabled) return;
      try {
        const ctx = getAudioCtx();
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(800, ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(400, ctx.currentTime + 0.05);
        gain.gain.setValueAtTime(0.3, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.08);
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.start(ctx.currentTime);
        osc.stop(ctx.currentTime + 0.08);
      } catch(e) {}
    }

    function playCaptureSound() {
      if (!G.soundEnabled) return;
      try {
        const ctx = getAudioCtx();
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(400, ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(150, ctx.currentTime + 0.1);
        gain.gain.setValueAtTime(0.4, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.12);
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.start(ctx.currentTime);
        osc.stop(ctx.currentTime + 0.12);
      } catch(e) {}
    }

    function playDiceSound() {
      if (!G.soundEnabled) return;
      try {
        const ctx = getAudioCtx();
        // Create white noise bursts to simulate dice rattle
        const bufferSize = ctx.sampleRate * 0.3;
        const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
          data[i] = (Math.random() * 2 - 1) * 0.5;
        }
        const source = ctx.createBufferSource();
        source.buffer = buffer;

        const bandpass = ctx.createBiquadFilter();
        bandpass.type = 'bandpass';
        bandpass.frequency.setValueAtTime(3000, ctx.currentTime);
        bandpass.Q.setValueAtTime(1.5, ctx.currentTime);

        const gain = ctx.createGain();
        gain.gain.setValueAtTime(0.25, ctx.currentTime);
        // Stuttered envelope for rattle effect
        gain.gain.setValueAtTime(0.25, ctx.currentTime + 0.02);
        gain.gain.setValueAtTime(0.08, ctx.currentTime + 0.04);
        gain.gain.setValueAtTime(0.2, ctx.currentTime + 0.06);
        gain.gain.setValueAtTime(0.05, ctx.currentTime + 0.1);
        gain.gain.setValueAtTime(0.15, ctx.currentTime + 0.14);
        gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.3);

        source.connect(bandpass);
        bandpass.connect(gain);
        gain.connect(ctx.destination);
        source.start(ctx.currentTime);
        source.stop(ctx.currentTime + 0.3);
      } catch(e) {}
    }

    function playVictoryFanfare() {
      if (!G.soundEnabled) return;
      try {
        const ctx = getAudioCtx();
        // Rising arpeggio: C5, E5, G5, C6
        const notes = [523.25, 659.25, 783.99, 1046.50];
        const noteLength = 0.15;

        notes.forEach((freq, i) => {
          const osc = ctx.createOscillator();
          const gain = ctx.createGain();
          osc.type = 'sine';
          osc.frequency.setValueAtTime(freq, ctx.currentTime);

          const startTime = ctx.currentTime + i * noteLength;
          const isLast = i === notes.length - 1;
          const dur = isLast ? 0.5 : noteLength;

          gain.gain.setValueAtTime(0, startTime);
          gain.gain.linearRampToValueAtTime(0.25, startTime + 0.02);
          gain.gain.setValueAtTime(0.25, startTime + dur * 0.7);
          gain.gain.exponentialRampToValueAtTime(0.001, startTime + dur);

          osc.connect(gain);
          gain.connect(ctx.destination);
          osc.start(startTime);
          osc.stop(startTime + dur);
        });

        // Final chord (C5+E5+G5) sustained
        const chordStart = ctx.currentTime + notes.length * noteLength;
        [523.25, 659.25, 783.99].forEach(freq => {
          const osc = ctx.createOscillator();
          const gain = ctx.createGain();
          osc.type = 'sine';
          osc.frequency.setValueAtTime(freq, chordStart);
          gain.gain.setValueAtTime(0, chordStart);
          gain.gain.linearRampToValueAtTime(0.15, chordStart + 0.05);
          gain.gain.exponentialRampToValueAtTime(0.001, chordStart + 0.8);
          osc.connect(gain);
          gain.connect(ctx.destination);
          osc.start(chordStart);
          osc.stop(chordStart + 0.8);
        });
      } catch(e) {}
    }

    function playErrorSound() {
      if (!G.soundEnabled) return;
      try {
        const ctx = getAudioCtx();
        // Gentle descending two-tone "boop-boop" error
        const notes = [440, 330]; // A4 → E4, a gentle minor fall
        notes.forEach((freq, i) => {
          const osc = ctx.createOscillator();
          const gain = ctx.createGain();
          osc.type = 'sine';
          osc.frequency.setValueAtTime(freq, ctx.currentTime);
          const start = ctx.currentTime + i * 0.12;
          gain.gain.setValueAtTime(0, start);
          gain.gain.linearRampToValueAtTime(0.2, start + 0.015);
          gain.gain.exponentialRampToValueAtTime(0.001, start + 0.12);
          osc.connect(gain);
          gain.connect(ctx.destination);
          osc.start(start);
          osc.stop(start + 0.12);
        });
      } catch(e) {}
    }

    // ════════════════════════════════════════════════
    //  ANIMATION — Checker movement
    // ════════════════════════════════════════════════

    let animationInProgress = false;

    /**
     * Get the screen bounding rect center of the last checker at a given location.
     * location: point number 1-24, 'bar', or 'off'
     * player: 'white' or 'black'
     * Returns {x, y, w, h} or null if not found.
     */
    function getCheckerPosition(location, player) {
      try {
        if (location === 'bar') {
          const barId = player === 'white' ? 'barWhite' : 'barBlack';
          const barEl = document.getElementById(barId);
          const checkers = barEl.querySelectorAll('.checker');
          if (checkers.length > 0) {
            const r = checkers[checkers.length - 1].getBoundingClientRect();
            return { x: r.left + r.width / 2, y: r.top + r.height / 2, w: r.width, h: r.height };
          }
          // If no checkers, use bar center
          const r = barEl.getBoundingClientRect();
          return { x: r.left + r.width / 2, y: r.top + r.height / 2, w: 30, h: 30 };
        }

        if (location === 'off') {
          const trayId = player === 'white' ? 'trayWhite' : 'trayBlack';
          const tray = document.getElementById(trayId);
          const r = tray.getBoundingClientRect();
          return { x: r.left + r.width / 2, y: r.top + r.height / 2, w: 30, h: 30 };
        }

        // Point 1-24
        const pointEl = document.querySelector(`.point[data-point="${location}"]`);
        if (!pointEl) return null;
        const checkers = pointEl.querySelectorAll('.checker');
        if (checkers.length > 0) {
          const r = checkers[checkers.length - 1].getBoundingClientRect();
          return { x: r.left + r.width / 2, y: r.top + r.height / 2, w: r.width, h: r.height };
        }
        // Empty point — use the point element center
        const r = pointEl.getBoundingClientRect();
        return { x: r.left + r.width / 2, y: r.top + r.height / 3, w: 30, h: 30 };
      } catch(e) {
        return null;
      }
    }

    /**
     * Animate a checker from source to destination.
     * srcPos, destPos: {x, y, w, h}
     * color: 'white' or 'black'
     * isBearOff: true if bearing off
     * Returns a Promise that resolves when animation completes.
     */
    function animateChecker(srcPos, destPos, color, isBearOff) {
      return new Promise(resolve => {
        if (!srcPos || !destPos) { resolve(); return; }

        const el = document.createElement('div');
        const size = srcPos.w || 30;
        el.className = `anim-checker ${color}`;
        el.style.width = size + 'px';
        el.style.height = size + 'px';
        el.style.left = (srcPos.x - size / 2) + 'px';
        el.style.top = (srcPos.y - size / 2) + 'px';
        document.body.appendChild(el);

        // Force reflow to apply initial position
        el.offsetHeight;

        // Add transition class and set destination
        el.classList.add(isBearOff ? 'bear-off' : 'animating');

        requestAnimationFrame(() => {
          el.style.left = (destPos.x - size / 2) + 'px';
          el.style.top = (destPos.y - size / 2) + 'px';
          if (isBearOff) {
            el.style.opacity = '0.3';
            el.style.transform = 'scale(0.5)';
          }
        });

        const onEnd = () => {
          el.removeEventListener('transitionend', onEnd);
          el.remove();
          resolve();
        };

        el.addEventListener('transitionend', onEnd);

        // Safety timeout — clean up after 500ms regardless
        setTimeout(() => {
          if (el.parentNode) {
            el.remove();
            resolve();
          }
        }, 500);
      });
    }

    /**
     * Animate the hit checker going to the bar.
     * hitPos: position of the hit blot on the destination
     * player: the player whose checker was hit (opponent)
     */
    function animateHitToBar(hitPos, player) {
      const barPos = getCheckerPosition('bar', player);
      if (!hitPos || !barPos) return Promise.resolve();
      return animateChecker(hitPos, barPos, player, false);
    }

    // ════════════════════════════════════════════════
    //  HELPERS
    // ════════════════════════════════════════════════

    function capitalize(s) { return s.charAt(0).toUpperCase() + s.slice(1); }

    /** Get player display name by color ('white' or 'black'). */
    function pName(color) { return G.playerNames[color]; }

    /** White moves low->high (+1, clockwise), black moves high->low (-1, counter-clockwise). */
    function moveDir(player) { return player === 'white' ? 1 : -1; }

    /** Bar index: white bar = 0, black bar = 25. */
    function barIdx(player) { return player === 'white' ? 0 : 25; }

    function hasBar(player) { return G.board[barIdx(player)] > 0; }

    function ownsPoint(board, point, player) {
      const v = board[point];
      return player === 'white' ? v > 0 : v < 0;
    }

    /** Can player land on this point? Empty, own, or single opponent (blot). */
    function canLand(board, point, player) {
      if (point < 1 || point > 24) return false;
      const v = board[point];
      return player === 'white' ? v >= -1 : v <= 1;
    }

    /** Can player bear off? All checkers must be in home board (none on bar, none outside). */
    function canBearOff(board, player) {
      if (board[barIdx(player)] > 0) return false;
      if (player === 'white') {
        for (let p = 1; p <= 18; p++) {
          if (board[p] > 0) return false;
        }
      } else {
        for (let p = 7; p <= 24; p++) {
          if (board[p] < 0) return false;
        }
      }
      return true;
    }

    /** Check if a move will hit a blot. */
    function willHitBlot(board, to, player) {
      if (to === 'off' || to < 1 || to > 24) return false;
      const v = board[to];
      return (player === 'white' && v === -1) || (player === 'black' && v === 1);
    }

    // ════════════════════════════════════════════════
    //  SCORING — Win Type Calculation
    // ════════════════════════════════════════════════

    /**
     * Calculate win type after a player wins by bearing off all 15.
     * Returns { type: 'normal'|'gammon'|'backgammon', multiplier: 1|2|3 }
     */
    function calculateWinType(winner) {
      const loser = winner === 'white' ? 'black' : 'white';
      const loserBorneOff = G.borneOff[loser];

      // If loser has borne off any checkers, it's a normal win
      if (loserBorneOff > 0) {
        return { type: 'normal', multiplier: 1 };
      }

      // Loser has borne off zero — check for backgammon
      // Backgammon: loser has checkers on the bar or in the winner's home board
      let hasInWinnerHome = false;

      if (winner === 'white') {
        // Winner is white, home board = 19-24. Check if black has checkers there or on bar.
        if (G.board[25] > 0) hasInWinnerHome = true;  // black on bar
        if (!hasInWinnerHome) {
          for (let p = 19; p <= 24; p++) {
            if (G.board[p] < 0) { hasInWinnerHome = true; break; }
          }
        }
      } else {
        // Winner is black, home board = 1-6. Check if white has checkers there or on bar.
        if (G.board[0] > 0) hasInWinnerHome = true;  // white on bar
        if (!hasInWinnerHome) {
          for (let p = 1; p <= 6; p++) {
            if (G.board[p] > 0) { hasInWinnerHome = true; break; }
          }
        }
      }

      if (hasInWinnerHome) {
        return { type: 'backgammon', multiplier: 3 };
      }

      return { type: 'gammon', multiplier: 2 };
    }

    // ════════════════════════════════════════════════
    //  BOARD INIT
    // ════════════════════════════════════════════════

    function initBoard() {
      G.board = new Array(26).fill(0);
      for (const [p, count] of Object.entries(STARTING_POSITION)) {
        G.board[parseInt(p)] = count;
      }
      G.borneOff = { white: 0, black: 0 };
    }

    // ════════════════════════════════════════════════
    //  MOVE SIMULATION (works on any board array)
    // ════════════════════════════════════════════════

    /** Apply a move to a board array (mutates). */
    function applyMove(board, move, player) {
      const { from, to } = move;

      // Remove from source
      if (from === 'bar') {
        board[barIdx(player)]--;
      } else {
        board[from] += player === 'white' ? -1 : 1;
      }

      // Bear-off: checker leaves the board entirely
      if (to === 'off') return;

      // Check for blot
      const dest = board[to];
      const isBlot = (player === 'white' && dest === -1) ||
                     (player === 'black' && dest === 1);
      if (isBlot) {
        const opp = player === 'white' ? 'black' : 'white';
        board[barIdx(opp)]++;
        board[to] = 0;
      }

      // Place at destination
      board[to] += player === 'white' ? 1 : -1;
    }

    /** Calculate raw legal moves for a board state + player + diceRemaining. */
    function calcMoves(board, player, dice) {
      const dir = moveDir(player);
      const unique = [...new Set(dice)];
      const moves = [];
      const bi = barIdx(player);

      if (board[bi] > 0) {
        for (const dv of unique) {
          const entry = player === 'white' ? dv : 25 - dv;
          if (canLand(board, entry, player)) {
            moves.push({ from: 'bar', to: entry, dieValue: dv });
          }
        }
        return moves;
      }

      const bearingOff = canBearOff(board, player);

      for (let p = 1; p <= 24; p++) {
        if (!ownsPoint(board, p, player)) continue;
        for (const dv of unique) {
          const dest = p + dir * dv;
          if (dest >= 1 && dest <= 24 && canLand(board, dest, player)) {
            moves.push({ from: p, to: dest, dieValue: dv });
          } else if (bearingOff && (dest < 1 || dest > 24)) {
            if (player === 'white' && dest === 25) {
              moves.push({ from: p, to: 'off', dieValue: dv });
            } else if (player === 'black' && dest === 0) {
              moves.push({ from: p, to: 'off', dieValue: dv });
            } else {
              let isFurthest = true;
              if (player === 'white') {
                for (let q = 19; q < p; q++) {
                  if (board[q] > 0) { isFurthest = false; break; }
                }
              } else {
                for (let q = 6; q > p; q--) {
                  if (board[q] < 0) { isFurthest = false; break; }
                }
              }
              if (isFurthest) {
                moves.push({ from: p, to: 'off', dieValue: dv });
              }
            }
          }
        }
      }
      return moves;
    }

    // ════════════════════════════════════════════════
    //  "MUST USE BOTH DICE" FILTER
    // ════════════════════════════════════════════════

    function filterMaxUsage(candidates, board, player, remaining) {
      if (remaining.length <= 1) return candidates;
      if (new Set(remaining).size === 1) return candidates;

      const useBoth = [];
      const byDie = {};

      for (const move of candidates) {
        const bCopy = [...board];
        applyMove(bCopy, move, player);

        const rest = [...remaining];
        rest.splice(rest.indexOf(move.dieValue), 1);

        const secondMoves = calcMoves(bCopy, player, rest);
        if (secondMoves.length > 0) {
          useBoth.push(move);
        }

        if (!byDie[move.dieValue]) byDie[move.dieValue] = [];
        byDie[move.dieValue].push(move);
      }

      if (useBoth.length > 0) return useBoth;

      const sorted = [...new Set(remaining)].sort((a, b) => b - a);
      for (const dv of sorted) {
        if (byDie[dv] && byDie[dv].length > 0) return byDie[dv];
      }

      return [];
    }

    /** Top-level: calculate all legal moves for current game state. */
    function calculateAllLegalMoves() {
      const raw = calcMoves(G.board, G.currentPlayer, G.dice.remaining);
      return filterMaxUsage(raw, G.board, G.currentPlayer, G.dice.remaining);
    }

    /**
     * Calculate combined-dice destinations for a selected checker.
     */
    function calcCombinedTargets(fromPoint, moves) {
      const remaining = G.dice.remaining;
      if (remaining.length < 2) return [];

      const player = G.currentPlayer;
      const combined = new Set();

      for (const m1 of moves) {
        if (m1.to === 'off') continue; // can't continue from bear-off
        const bCopy = [...G.board];
        applyMove(bCopy, m1, player);

        const rest = [...remaining];
        rest.splice(rest.indexOf(m1.dieValue), 1);

        const dir = moveDir(player);
        const uniqueRest = [...new Set(rest)];
        for (const dv of uniqueRest) {
          const dest = m1.to + dir * dv;
          if (dest >= 1 && dest <= 24 && canLand(bCopy, dest, player)) {
            combined.add(dest);
          }
        }
      }

      const directTargets = new Set(moves.map(m => m.to));
      for (const t of directTargets) {
        combined.delete(t);
      }

      return [...combined];
    }

    // ════════════════════════════════════════════════
    //  AI — Utility helpers
    // ════════════════════════════════════════════════

    function isAITurn() {
      return G.mode === 'pvai' && G.currentPlayer === 'black';
    }

    /** Calculate pip count for a player on a given board. */
    function pipCount(board, player) {
      let count = 0;
      if (player === 'white') {
        count += board[0] * 25; // bar checkers need 25 pips to bear off
        for (let p = 1; p <= 24; p++) {
          if (board[p] > 0) count += board[p] * (25 - p);
        }
      } else {
        count += board[25] * 25;
        for (let p = 1; p <= 24; p++) {
          if (board[p] < 0) count += Math.abs(board[p]) * p;
        }
      }
      return count;
    }

    /** Count how many blots (single checkers) a player has on the board. */
    function countBlots(board, player) {
      let n = 0;
      for (let p = 1; p <= 24; p++) {
        if (player === 'white' && board[p] === 1) n++;
        if (player === 'black' && board[p] === -1) n++;
      }
      return n;
    }

    /** Count how many points a player owns (2+ checkers). */
    function countOwnedPoints(board, player) {
      let n = 0;
      for (let p = 1; p <= 24; p++) {
        if (player === 'white' && board[p] >= 2) n++;
        if (player === 'black' && board[p] <= -2) n++;
      }
      return n;
    }

    /** Count consecutive owned points (prime length) starting from a point. */
    function longestPrime(board, player) {
      let best = 0;
      let run = 0;
      for (let p = 1; p <= 24; p++) {
        if ((player === 'white' && board[p] >= 2) || (player === 'black' && board[p] <= -2)) {
          run++;
          if (run > best) best = run;
        } else {
          run = 0;
        }
      }
      return best;
    }

    /** Check if a point is in a player's home board. */
    function isHomeBoard(point, player) {
      return player === 'white' ? (point >= 19 && point <= 24) : (point >= 1 && point <= 6);
    }

    /** Check if a point is in a player's inner board (home board). */
    function isInnerBoard(point, player) {
      return isHomeBoard(point, player);
    }

    // ════════════════════════════════════════════════
    //  AI — Sequence generator (finds all move sequences)
    // ════════════════════════════════════════════════

    /**
     * Generate all possible complete move sequences for the AI.
     * Returns array of { moves: [{from,to,dieValue},...], resultBoard: [...] }
     */
    function generateAllSequences(board, player, remaining) {
      const sequences = [];

      function recurse(curBoard, curRemaining, curMoves) {
        const raw = calcMoves(curBoard, player, curRemaining);
        const filtered = filterMaxUsage(raw, curBoard, player, curRemaining);

        if (filtered.length === 0) {
          // Terminal state — record this sequence
          sequences.push({ moves: [...curMoves], resultBoard: [...curBoard] });
          return;
        }

        // Deduplicate by (from, to) to avoid redundant branches
        const seen = new Set();
        for (const move of filtered) {
          const key = `${move.from}-${move.to}-${move.dieValue}`;
          if (seen.has(key)) continue;
          seen.add(key);

          const nextBoard = [...curBoard];
          applyMove(nextBoard, move, player);

          const nextRemaining = [...curRemaining];
          nextRemaining.splice(nextRemaining.indexOf(move.dieValue), 1);

          curMoves.push(move);
          recurse(nextBoard, nextRemaining, curMoves);
          curMoves.pop();
        }
      }

      recurse([...board], [...remaining], []);

      // If no sequences generated, add empty sequence
      if (sequences.length === 0) {
        sequences.push({ moves: [], resultBoard: [...board] });
      }

      return sequences;
    }

    // ════════════════════════════════════════════════
    //  AI — Exposure Calculator
    // ════════════════════════════════════════════════

    // Precomputed: how many of 36 possible dice outcomes can reach distance d (direct shots only)
    const DIRECT_SHOT_COUNTS = [0,11,12,14,15,15,17,6,6,5,3,2,3,0,0,0,1,0,0,0,1,0,0,0,1];

    /** Calculate total exposure (shot vulnerability) for a player's blots. */
    function calculateExposure(board, player) {
      let exposure = 0;
      const sign = player === 'white' ? 1 : -1;
      const oppSign = -sign;
      const oppBar = player === 'white' ? 25 : 0;

      for (let p = 1; p <= 24; p++) {
        // Is this point a blot for this player?
        if (board[p] * sign !== 1) continue;

        // Check opponent bar checkers
        if (board[oppBar] > 0) {
          const dist = player === 'white' ? p : (25 - p);
          if (dist >= 1 && dist <= 24) exposure += DIRECT_SHOT_COUNTS[dist];
        }

        // Check each opponent checker on the board
        for (let q = 1; q <= 24; q++) {
          if (board[q] * oppSign <= 0) continue; // no opponent checkers here
          const dist = player === 'white' ? (p - q) : (q - p);
          if (dist >= 1 && dist <= 24) {
            exposure += DIRECT_SHOT_COUNTS[dist] * Math.abs(board[q]);
          }
        }
      }
      return exposure;
    }

    // ════════════════════════════════════════════════
    //  AI — New Utility Functions
    // ════════════════════════════════════════════════

    /** Count anchors (made points) in opponent's home board. */
    function countAnchors(board, player) {
      let n = 0;
      if (player === 'black') {
        // Black's anchors are in white's home (points 19-24)
        for (let p = 19; p <= 24; p++) {
          if (board[p] <= -2) n++;
        }
      } else {
        // White's anchors are in black's home (points 1-6)
        for (let p = 1; p <= 6; p++) {
          if (board[p] >= 2) n++;
        }
      }
      return n;
    }

    /** Count made points in own home board. */
    function homeBoardStrength(board, player) {
      let n = 0;
      if (player === 'black') {
        for (let p = 1; p <= 6; p++) {
          if (board[p] <= -2) n++;
        }
      } else {
        for (let p = 19; p <= 24; p++) {
          if (board[p] >= 2) n++;
        }
      }
      return n;
    }

    /** Count checkers borne off. */
    function countBorneOff(board, player) {
      let onBoard = 0;
      const bar = player === 'white' ? 0 : 25;
      onBoard += board[bar]; // bar checkers
      for (let p = 1; p <= 24; p++) {
        if (player === 'white' && board[p] > 0) onBoard += board[p];
        if (player === 'black' && board[p] < 0) onBoard += Math.abs(board[p]);
      }
      return 15 - onBoard;
    }

    /** Count new blots created by a sequence that are exposed to direct shots. */
    function countNewExposedBlots(seq, originalBoard) {
      const board = seq.resultBoard;
      let count = 0;
      for (let p = 1; p <= 24; p++) {
        // New blot: was not a blot before, is a blot now
        if (board[p] === -1 && originalBoard[p] !== -1) {
          // Check if any white checker can hit this in direct range (1-6)
          let exposed = false;
          // Check white bar
          if (originalBoard[0] > 0) {
            const dist = 25 - p; // white enters from bar
            if (dist >= 1 && dist <= 6) exposed = true;
          }
          for (let q = 1; q <= 24; q++) {
            if (board[q] > 0) { // white checker at q
              const dist = p - q; // white moves low to high, so hits at p if p > q... wait
              // White moves in + direction. White at q can hit black blot at p if q < p and dist = p - q
              // But also white at q can hit if q > p... no, white moves q -> q+die
              // White checker at q hits point t = q + die. So to hit p: die = p - q, need p - q in 1..6
              const d = p - q;
              if (d >= 1 && d <= 6) { exposed = true; break; }
            }
          }
          if (exposed) count++;
        }
      }
      return count;
    }

    /** Count bear-offs in a move sequence. */
    function countBearOffs(seq) {
      let n = 0;
      for (const m of seq.moves) {
        if (m.to === 'off') n++;
      }
      return n;
    }

    /** Count hits in a move sequence. */
    function countHits(seq, originalBoard) {
      // Count by checking white bar increase
      return seq.resultBoard[0] - originalBoard[0];
    }

    /** Count new made points created by a sequence. */
    function countNewMadePoints(seq, originalBoard) {
      const board = seq.resultBoard;
      let n = 0;
      for (let p = 1; p <= 24; p++) {
        if (board[p] <= -2 && originalBoard[p] > -2) n++;
      }
      return n;
    }

    /** Check if sequence enters from bar. */
    function seqEntersFromBar(seq) {
      for (const m of seq.moves) {
        if (m.from === 'bar') return true;
      }
      return false;
    }

    // ════════════════════════════════════════════════
    //  AI — Feature Extractor
    // ════════════════════════════════════════════════

    /** Extract position features for AI evaluation. */
    function extractFeatures(board, player) {
      const opp = player === 'white' ? 'black' : 'white';
      return {
        pipCount: pipCount(board, player),
        oppPipCount: pipCount(board, opp),
        madePoints: countOwnedPoints(board, player),
        blots: countBlots(board, player),
        exposure: calculateExposure(board, player),
        longestPrime: longestPrime(board, player),
        anchors: countAnchors(board, player),
        homeBoardStrength: homeBoardStrength(board, player),
        barCheckers: board[player === 'white' ? 0 : 25],
        oppBarCheckers: board[player === 'white' ? 25 : 0],
        oppHomeBoardStrength: homeBoardStrength(board, opp),
        hasContact: hasContact(board),
        borneOff: countBorneOff(board, player)
      };
    }

    // ════════════════════════════════════════════════
    //  AI — Contact Detection (preserved)
    // ════════════════════════════════════════════════

    /** Check if there is any contact between players (checkers can still interact). */
    function hasContact(board) {
      if (board[0] > 0) return true;  // white on bar
      if (board[25] > 0) return true; // black on bar

      // White moves 1→24. White's rearmost = lowest point with white checker.
      let whiteRear = 25;
      for (let p = 1; p <= 24; p++) {
        if (board[p] > 0) { whiteRear = p; break; }
      }

      // Black moves 24→1. Black's rearmost = highest point with black checker.
      let blackRear = 0;
      for (let p = 24; p >= 1; p--) {
        if (board[p] < 0) { blackRear = p; break; }
      }

      // No contact (pure race) only if white's rearmost has passed black's rearmost.
      // i.e., white's least-advanced checker is already ahead of black's least-advanced.
      // Contact exists if they can still interact.
      return whiteRear <= blackRear;
    }

    // ════════════════════════════════════════════════
    //  AI — Position Classifier
    // ════════════════════════════════════════════════

    /**
     * Classify current position type for mode-specific evaluation.
     * SURVIVAL: on the bar or opponent has strong home board (dangerous)
     * RACE: no contact between armies
     * CONTACT: default (midgame fighting position)
     */
    function classifyPosition(features) {
      if (features.barCheckers > 0 || features.oppHomeBoardStrength >= 4) {
        return 'SURVIVAL';
      }
      if (!features.hasContact) {
        return 'RACE';
      }
      return 'CONTACT';
    }

    // ════════════════════════════════════════════════
    //  AI — Weight Tables + Scoring
    // ════════════════════════════════════════════════

    const AI_WEIGHTS = {
      CONTACT: {
        hit: 35, makePoint: 30, anchor: 25, homeBoard: 20,
        blotExposure: -25, breakPrime: -20, pipAdvance: 5,
        enterBar: 30, bearOff: 15, prime: 25,
        keyPoint: 20, stackPenalty: -8
      },
      RACE: {
        hit: 10, makePoint: 10, anchor: 0, homeBoard: 15,
        blotExposure: -5, breakPrime: -5, pipAdvance: 30,
        enterBar: 10, bearOff: 25, prime: 5,
        keyPoint: 5, stackPenalty: -12, homeDistribution: 20, gap: -10
      },
      SURVIVAL: {
        hit: 20, makePoint: 25, anchor: 30, homeBoard: 20,
        blotExposure: -30, breakPrime: -15, pipAdvance: 3,
        enterBar: 40, bearOff: 10, prime: 15,
        keyPoint: 15, stackPenalty: -5, multiBlot: -30
      }
    };

    /** Score a move sequence using mode-specific weights. */
    function scoreSequence(seq, originalBoard, mode) {
      const board = seq.resultBoard;
      const player = 'black';
      const W = AI_WEIGHTS[mode] || AI_WEIGHTS.CONTACT;

      const featuresBefore = extractFeatures(originalBoard, player);
      const featuresAfter = extractFeatures(board, player);

      let score = 0;

      // Hits
      const hits = countHits(seq, originalBoard);
      score += hits * W.hit;

      // New made points
      const newPoints = countNewMadePoints(seq, originalBoard);
      score += newPoints * W.makePoint;

      // Anchor changes
      const anchorDelta = featuresAfter.anchors - featuresBefore.anchors;
      score += anchorDelta * W.anchor;

      // Home board strength changes
      const hbDelta = featuresAfter.homeBoardStrength - featuresBefore.homeBoardStrength;
      score += hbDelta * W.homeBoard;

      // Blot exposure change (negative weight = penalizes increase)
      const exposureDelta = featuresAfter.exposure - featuresBefore.exposure;
      if (exposureDelta > 0) {
        score += (exposureDelta / 36) * W.blotExposure; // normalize by 36
      }

      // New exposed blots penalty
      const newExposed = countNewExposedBlots(seq, originalBoard);
      score += newExposed * (W.blotExposure * 0.5);

      // Prime changes
      const primeDelta = featuresAfter.longestPrime - featuresBefore.longestPrime;
      score += primeDelta * W.prime;

      // Breaking a prime (prime got shorter)
      if (primeDelta < 0) {
        score += primeDelta * Math.abs(W.breakPrime);
      }

      // Pip advancement
      const pipDelta = featuresBefore.pipCount - featuresAfter.pipCount;
      score += pipDelta * (W.pipAdvance / 10); // scale down

      // Bar entry
      if (seqEntersFromBar(seq)) {
        score += W.enterBar;
      }

      // Bear-offs
      const bearOffs = countBearOffs(seq);
      score += bearOffs * W.bearOff;

      // Key points for black (5-point, 4-point, bar-point)
      if (board[5] <= -2 && originalBoard[5] > -2) score += W.keyPoint * 1.2;
      if (board[4] <= -2 && originalBoard[4] > -2) score += W.keyPoint;
      if (board[7] <= -2 && originalBoard[7] > -2) score += W.keyPoint * 0.9;
      if (board[3] <= -2 && originalBoard[3] > -2) score += W.keyPoint * 0.7;

      // Stack penalty: penalize stacking 4+ on one point (inefficient)
      for (let p = 1; p <= 24; p++) {
        if (board[p] <= -4) {
          const excess = Math.abs(board[p]) - 3;
          score += excess * W.stackPenalty;
        }
      }

      // Mode-specific bonuses
      if (mode === 'RACE' && W.homeDistribution) {
        // Reward even distribution in home board during race
        let homeCheckers = 0;
        let homePointsUsed = 0;
        for (let p = 1; p <= 6; p++) {
          if (board[p] < 0) {
            homeCheckers += Math.abs(board[p]);
            homePointsUsed++;
          }
        }
        if (homePointsUsed > 0) {
          score += (homePointsUsed / 6) * W.homeDistribution;
        }
        // Penalize gaps in home board
        for (let p = 1; p <= 5; p++) {
          if (board[p] === 0 && board[p + 1] < 0) {
            score += W.gap || 0;
          }
        }
      }

      if (mode === 'SURVIVAL' && W.multiBlot) {
        // Extra penalty for multiple blots in survival mode
        const blotCount = featuresAfter.blots;
        if (blotCount >= 3) {
          score += (blotCount - 2) * W.multiBlot;
        }
      }

      return score;
    }

    /** Simple flat-weight scoring for beginner AI. */
    function scoreSequenceSimple(seq, originalBoard) {
      const board = seq.resultBoard;
      let score = 0;

      // +30 hit
      score += countHits(seq, originalBoard) * 30;

      // +20 make point
      score += countNewMadePoints(seq, originalBoard) * 20;

      // +10 home board improvement
      const hbBefore = homeBoardStrength(originalBoard, 'black');
      const hbAfter = homeBoardStrength(board, 'black');
      score += (hbAfter - hbBefore) * 10;

      // +15 bear off
      score += countBearOffs(seq) * 15;

      // -20 exposed blot
      score -= countNewExposedBlots(seq, originalBoard) * 20;

      // -15 break point (lost a made point)
      const ownedBefore = countOwnedPoints(originalBoard, 'black');
      const ownedAfter = countOwnedPoints(board, 'black');
      if (ownedAfter < ownedBefore) {
        score += (ownedAfter - ownedBefore) * 15;
      }

      // +5 pip reduction
      const pipDelta = pipCount(originalBoard, 'black') - pipCount(board, 'black');
      score += pipDelta * 0.5;

      // +10 entering from bar
      if (seqEntersFromBar(seq)) score += 10;

      return score;
    }

    // ════════════════════════════════════════════════
    //  AI — Anti-Blunder Filter
    // ════════════════════════════════════════════════

    /**
     * Detect blunder moves for the beginner AI to avoid.
     * Returns true if the sequence is a blunder.
     */
    function isBlunder(seq, originalBoard) {
      // Blunder: creates 3+ new blots that are exposed to direct shots
      const newExposed = countNewExposedBlots(seq, originalBoard);
      if (newExposed >= 3) return true;

      // Blunder: breaks a home-board made point UNLESS the play also
      // hits, makes a new point, enters from bar, or bears off
      const board = seq.resultBoard;
      for (let p = 1; p <= 6; p++) {
        if (originalBoard[p] <= -2 && board[p] > -2) {
          // Broke a home board point — check for redeeming actions
          const hits = countHits(seq, originalBoard);
          const newPoints = countNewMadePoints(seq, originalBoard);
          const enters = seqEntersFromBar(seq);
          const bearOffs = countBearOffs(seq);

          if (hits > 0 || newPoints > 0 || enters || bearOffs > 0) {
            return false; // has a redeeming action
          }
          return true; // broke home board point with nothing to show for it
        }
      }

      return false;
    }

    // ════════════════════════════════════════════════
    //  AI — Console Logging
    // ════════════════════════════════════════════════

    function aiLog(difficulty, roll, mode, play, score, details) {
      const tag = `[AI-${difficulty.toUpperCase()}]`;
      const rollStr = `Roll: ${roll[0]}-${roll[1]}`;
      const modeStr = mode ? `Mode: ${mode}` : '';

      let playStr = 'No moves';
      if (play && play.moves && play.moves.length > 0) {
        playStr = play.moves.map(m => {
          const fromStr = m.from === 'bar' ? 'bar' : m.from;
          const toStr = m.to === 'off' ? 'off' : m.to;
          return `${fromStr}→${toStr}`;
        }).join(', ');
      }

      const parts = [tag, rollStr];
      if (modeStr) parts.push(modeStr);
      parts.push(`Play: ${playStr}`);
      parts.push(`Score: ${Math.round(score)}`);
      if (details) parts.push(details);

      console.log(parts.join(' | '));
    }

    // ════════════════════════════════════════════════
    //  AI — Beginner (anti-blunder + weighted random)
    // ════════════════════════════════════════════════

    function aiBeginnerChooseSequence(sequences, originalBoard) {
      if (sequences.length <= 1) return sequences[0] || null;

      // 1. Filter out blunders
      const nonBlunders = sequences.filter(seq => !isBlunder(seq, originalBoard));
      const candidates = nonBlunders.length > 0 ? nonBlunders : sequences;

      // 2. Score remaining with simple scoring
      const scored = candidates.map(seq => ({
        seq,
        score: scoreSequenceSimple(seq, originalBoard)
      }));

      // 3. Sort by score descending
      scored.sort((a, b) => b.score - a.score);

      // 4. Take top 40%
      const topCount = Math.max(1, Math.ceil(scored.length * 0.4));
      const topCandidates = scored.slice(0, topCount);

      // 5. Weighted random selection (probability proportional to score)
      // Shift scores to be positive for weighting
      const minScore = topCandidates[topCandidates.length - 1].score;
      const shift = minScore < 0 ? Math.abs(minScore) + 1 : 1;
      const totalWeight = topCandidates.reduce((sum, c) => sum + c.score + shift, 0);

      let rand = Math.random() * totalWeight;
      let chosen = topCandidates[0];
      for (const c of topCandidates) {
        rand -= (c.score + shift);
        if (rand <= 0) { chosen = c; break; }
      }

      // Console log
      const roll = G.dice.values || [0, 0];
      aiLog('beginner', roll, null, chosen.seq, chosen.score,
        `Candidates: ${candidates.length}/${sequences.length} (filtered ${sequences.length - candidates.length} blunders)`);

      return chosen.seq;
    }

    // ════════════════════════════════════════════════
    //  AI — Web Worker for Punishability Simulation
    // ════════════════════════════════════════════════

    let aiWorker = null;
    let aiWorkerReady = false;

    function createAIWorker() {
      const workerCode = `
        // ── Pure functions replicated for Worker context ──
        function moveDir(player) { return player === 'white' ? 1 : -1; }
        function barIdx(player) { return player === 'white' ? 0 : 25; }
        function ownsPoint(board, point, player) {
          const v = board[point];
          return player === 'white' ? v > 0 : v < 0;
        }
        function canLand(board, point, player) {
          if (point < 1 || point > 24) return false;
          const v = board[point];
          return player === 'white' ? v >= -1 : v <= 1;
        }
        function canBearOff(board, player) {
          if (board[barIdx(player)] > 0) return false;
          if (player === 'white') {
            for (let p = 1; p <= 18; p++) { if (board[p] > 0) return false; }
          } else {
            for (let p = 7; p <= 24; p++) { if (board[p] < 0) return false; }
          }
          return true;
        }
        function applyMove(board, move, player) {
          const { from, to } = move;
          if (from === 'bar') { board[barIdx(player)]--; }
          else { board[from] += player === 'white' ? -1 : 1; }
          if (to === 'off') return;
          const dest = board[to];
          const isBlot = (player === 'white' && dest === -1) || (player === 'black' && dest === 1);
          if (isBlot) {
            const opp = player === 'white' ? 'black' : 'white';
            board[barIdx(opp)]++;
            board[to] = 0;
          }
          board[to] += player === 'white' ? 1 : -1;
        }
        function calcMoves(board, player, dice) {
          const dir = moveDir(player);
          const unique = [...new Set(dice)];
          const moves = [];
          const bi = barIdx(player);
          if (board[bi] > 0) {
            for (const dv of unique) {
              const entry = player === 'white' ? dv : 25 - dv;
              if (canLand(board, entry, player)) {
                moves.push({ from: 'bar', to: entry, dieValue: dv });
              }
            }
            return moves;
          }
          const bearingOff = canBearOff(board, player);
          for (let p = 1; p <= 24; p++) {
            if (!ownsPoint(board, p, player)) continue;
            for (const dv of unique) {
              const dest = p + dir * dv;
              if (dest >= 1 && dest <= 24 && canLand(board, dest, player)) {
                moves.push({ from: p, to: dest, dieValue: dv });
              } else if (bearingOff && (dest < 1 || dest > 24)) {
                if (player === 'white' && dest === 25) {
                  moves.push({ from: p, to: 'off', dieValue: dv });
                } else if (player === 'black' && dest === 0) {
                  moves.push({ from: p, to: 'off', dieValue: dv });
                } else {
                  let isFurthest = true;
                  if (player === 'white') {
                    for (let q = 19; q < p; q++) { if (board[q] > 0) { isFurthest = false; break; } }
                  } else {
                    for (let q = 6; q > p; q--) { if (board[q] < 0) { isFurthest = false; break; } }
                  }
                  if (isFurthest) moves.push({ from: p, to: 'off', dieValue: dv });
                }
              }
            }
          }
          return moves;
        }
        function filterMaxUsage(candidates, board, player, remaining) {
          if (remaining.length <= 1) return candidates;
          if (new Set(remaining).size === 1) return candidates;
          const useBoth = [];
          const byDie = {};
          for (const move of candidates) {
            const bCopy = [...board];
            applyMove(bCopy, move, player);
            const rest = [...remaining];
            rest.splice(rest.indexOf(move.dieValue), 1);
            const secondMoves = calcMoves(bCopy, player, rest);
            if (secondMoves.length > 0) useBoth.push(move);
            if (!byDie[move.dieValue]) byDie[move.dieValue] = [];
            byDie[move.dieValue].push(move);
          }
          if (useBoth.length > 0) return useBoth;
          const sorted = [...new Set(remaining)].sort((a, b) => b - a);
          for (const dv of sorted) {
            if (byDie[dv] && byDie[dv].length > 0) return byDie[dv];
          }
          return [];
        }
        function generateAllSequences(board, player, remaining) {
          const sequences = [];
          function recurse(curBoard, curRemaining, curMoves) {
            const raw = calcMoves(curBoard, player, curRemaining);
            const filtered = filterMaxUsage(raw, curBoard, player, curRemaining);
            if (filtered.length === 0) {
              if (curMoves.length > 0) {
                sequences.push({ moves: [...curMoves], resultBoard: [...curBoard] });
              }
              return;
            }
            const seen = new Set();
            for (const move of filtered) {
              const key = move.from + '-' + move.to + '-' + move.dieValue;
              if (seen.has(key)) continue;
              seen.add(key);
              const nextBoard = [...curBoard];
              applyMove(nextBoard, move, player);
              const nextRemaining = [...curRemaining];
              nextRemaining.splice(nextRemaining.indexOf(move.dieValue), 1);
              curMoves.push(move);
              recurse(nextBoard, nextRemaining, curMoves);
              curMoves.pop();
            }
          }
          recurse([...board], [...remaining], []);
          if (sequences.length === 0) {
            sequences.push({ moves: [], resultBoard: [...board] });
          }
          return sequences;
        }
        function pipCount(board, player) {
          let count = 0;
          if (player === 'white') {
            count += board[0] * 25;
            for (let p = 1; p <= 24; p++) { if (board[p] > 0) count += board[p] * (25 - p); }
          } else {
            count += board[25] * 25;
            for (let p = 1; p <= 24; p++) { if (board[p] < 0) count += Math.abs(board[p]) * p; }
          }
          return count;
        }
        function countOwnedPoints(board, player) {
          let n = 0;
          for (let p = 1; p <= 24; p++) {
            if (player === 'white' && board[p] >= 2) n++;
            if (player === 'black' && board[p] <= -2) n++;
          }
          return n;
        }
        function countBlots(board, player) {
          let n = 0;
          for (let p = 1; p <= 24; p++) {
            if (player === 'white' && board[p] === 1) n++;
            if (player === 'black' && board[p] === -1) n++;
          }
          return n;
        }

        // Simple scoring for opponent's response (how good is this for white?)
        function scoreOpponentResponse(seq, origBoard) {
          const board = seq.resultBoard;
          let score = 0;
          // Hits on black
          score += (board[25] - origBoard[25]) * 35;
          // Points made
          score += (countOwnedPoints(board, 'white') - countOwnedPoints(origBoard, 'white')) * 20;
          // Pip advancement
          score += (pipCount(origBoard, 'white') - pipCount(board, 'white')) * 2;
          // Blot reduction
          score -= (countBlots(board, 'white') - countBlots(origBoard, 'white')) * 15;
          return score;
        }

        // 21 distinct dice outcomes with frequencies (out of 36)
        const DICE_OUTCOMES = [
          {d:[1,1],w:1},{d:[2,2],w:1},{d:[3,3],w:1},{d:[4,4],w:1},{d:[5,5],w:1},{d:[6,6],w:1},
          {d:[1,2],w:2},{d:[1,3],w:2},{d:[1,4],w:2},{d:[1,5],w:2},{d:[1,6],w:2},
          {d:[2,3],w:2},{d:[2,4],w:2},{d:[2,5],w:2},{d:[2,6],w:2},
          {d:[3,4],w:2},{d:[3,5],w:2},{d:[3,6],w:2},
          {d:[4,5],w:2},{d:[4,6],w:2},
          {d:[5,6],w:2}
        ];

        self.onmessage = function(e) {
          const { candidates, id } = e.data;
          const results = [];

          for (let ci = 0; ci < candidates.length; ci++) {
            const cand = candidates[ci];
            const board = cand.resultBoard;
            let totalDamage = 0;
            let totalWeight = 0;

            for (const outcome of DICE_OUTCOMES) {
              const dice = outcome.d;
              const remaining = dice[0] === dice[1] ? [dice[0], dice[0], dice[0], dice[0]] : [dice[0], dice[1]];

              // Generate white's responses
              const oppSequences = generateAllSequences(board, 'white', remaining);

              // Cap at 50 sequences to avoid explosion
              const capped = oppSequences.length > 50 ? oppSequences.slice(0, 50) : oppSequences;

              // Find opponent's best response
              let bestOppScore = -Infinity;
              for (const seq of capped) {
                const s = scoreOpponentResponse(seq, board);
                if (s > bestOppScore) bestOppScore = s;
              }

              if (bestOppScore > -Infinity) {
                totalDamage += bestOppScore * outcome.w;
              }
              totalWeight += outcome.w;
            }

            results.push({
              index: cand.index,
              punishability: totalWeight > 0 ? totalDamage / totalWeight : 0
            });
          }

          self.postMessage({ results, id });
        };
      `;

      try {
        const blob = new Blob([workerCode], { type: 'application/javascript' });
        const url = URL.createObjectURL(blob);
        aiWorker = new Worker(url);
        aiWorkerReady = true;
        URL.revokeObjectURL(url);
        console.log('[AI] Web Worker created successfully');
      } catch (e) {
        console.warn('[AI] Web Worker creation failed, will use synchronous fallback:', e.message);
        aiWorkerReady = false;
      }
    }

    // Initialize worker on load
    createAIWorker();

    let aiWorkerMsgId = 0;

    /** Send candidates to Web Worker for punishability evaluation. Returns Promise. */
    function computePunishability(candidates) {
      if (!aiWorkerReady || !aiWorker) {
        // Synchronous fallback: reduced simulation with 10 random rolls
        return Promise.resolve(computePunishabilitySync(candidates));
      }

      const msgId = ++aiWorkerMsgId;

      return Promise.race([
        new Promise((resolve) => {
          const handler = (e) => {
            if (e.data.id === msgId) {
              aiWorker.removeEventListener('message', handler);
              resolve(e.data.results);
            }
          };
          aiWorker.addEventListener('message', handler);

          aiWorker.postMessage({
            candidates: candidates.map((c, i) => ({
              index: i,
              resultBoard: c.resultBoard
            })),
            id: msgId
          });
        }),
        // 3-second timeout fallback
        new Promise((resolve) => {
          setTimeout(() => {
            console.warn('[AI] Worker timeout — using static scores only');
            resolve(candidates.map((_, i) => ({ index: i, punishability: 0 })));
          }, 3000);
        })
      ]);
    }

    /** Synchronous fallback for punishability (10 random rolls). */
    function computePunishabilitySync(candidates) {
      // Simplified: use 10 random dice outcomes
      const SAMPLE_ROLLS = [
        [1,2],[3,4],[5,6],[2,3],[1,5],
        [4,6],[3,3],[1,1],[2,5],[6,4]
      ];

      return candidates.map((cand, i) => {
        const board = cand.resultBoard;
        let totalDamage = 0;

        for (const dice of SAMPLE_ROLLS) {
          const remaining = dice[0] === dice[1] ? [dice[0],dice[0],dice[0],dice[0]] : [...dice];
          const oppSeqs = generateAllSequences(board, 'white', remaining);
          const capped = oppSeqs.length > 30 ? oppSeqs.slice(0, 30) : oppSeqs;

          let bestOpp = -Infinity;
          for (const seq of capped) {
            const s = seq.resultBoard[25] - board[25]; // black bar increase = damage
            const ownedDelta = countOwnedPoints(seq.resultBoard, 'white') - countOwnedPoints(board, 'white');
            const pipDelta = pipCount(board, 'white') - pipCount(seq.resultBoard, 'white');
            const score = s * 35 + ownedDelta * 20 + pipDelta * 2;
            if (score > bestOpp) bestOpp = score;
          }

          if (bestOpp > -Infinity) totalDamage += bestOpp;
        }

        return { index: i, punishability: totalDamage / SAMPLE_ROLLS.length };
      });
    }

    // ════════════════════════════════════════════════
    //  AI — Intermediate (position-aware + punishability)
    // ════════════════════════════════════════════════

    async function aiIntermediateChooseSequence(sequences, originalBoard) {
      if (sequences.length <= 1) return sequences[0] || null;

      // 1. Classify position
      const features = extractFeatures(originalBoard, 'black');
      const mode = classifyPosition(features);

      // 2. Score all sequences with mode-specific weights
      const scored = sequences.map((seq, idx) => ({
        seq,
        index: idx,
        staticScore: scoreSequence(seq, originalBoard, mode),
        resultBoard: seq.resultBoard
      }));

      // 3. Sort and take top 10 candidates
      scored.sort((a, b) => b.staticScore - a.staticScore);
      const topCount = Math.min(10, scored.length);
      const topCandidates = scored.slice(0, topCount);

      // 4. Send to Web Worker for punishability
      let punishResults;
      try {
        punishResults = await computePunishability(topCandidates);
      } catch (e) {
        console.warn('[AI] Punishability computation failed:', e.message);
        punishResults = topCandidates.map((_, i) => ({ index: i, punishability: 0 }));
      }

      // 5. Combine: finalScore = staticScore - 0.5 * punishability
      const punishMap = {};
      for (const r of punishResults) {
        punishMap[r.index] = r.punishability;
      }

      const finalScored = topCandidates.map((c, i) => ({
        ...c,
        punishability: punishMap[i] || 0,
        finalScore: c.staticScore - 0.5 * (punishMap[i] || 0)
      }));

      finalScored.sort((a, b) => b.finalScore - a.finalScore);

      // 6. Selection: 75% pick best, 25% random from top 10%
      let chosen;
      if (Math.random() < 0.75 || finalScored.length <= 1) {
        chosen = finalScored[0];
      } else {
        const topSlice = Math.max(1, Math.ceil(finalScored.length * 0.1));
        const pool = finalScored.slice(0, Math.max(2, topSlice));
        chosen = pool[Math.floor(Math.random() * pool.length)];
      }

      // 7. Console log
      const roll = G.dice.values || [0, 0];
      aiLog('intermediate', roll, mode, chosen.seq, chosen.finalScore,
        `Static: ${Math.round(chosen.staticScore)} | Punish: ${Math.round(chosen.punishability)} | Net: ${Math.round(chosen.finalScore)}`);

      return chosen.seq;
    }

    // ════════════════════════════════════════════════
    //  AI — Professional (rollout-based with equity estimation)
    // ════════════════════════════════════════════════

    let proWorker = null;
    let proWorkerReady = false;

    function createProWorker() {
      const workerCode = `
        // ══════════════════════════════════════════
        // Pure game functions (same as intermediate worker)
        // ══════════════════════════════════════════
        function moveDir(player) { return player === 'white' ? 1 : -1; }
        function barIdx(player) { return player === 'white' ? 0 : 25; }
        function ownsPoint(board, point, player) {
          const v = board[point];
          return player === 'white' ? v > 0 : v < 0;
        }
        function canLand(board, point, player) {
          if (point < 1 || point > 24) return false;
          const v = board[point];
          return player === 'white' ? v >= -1 : v <= 1;
        }
        function canBearOff(board, player) {
          if (board[barIdx(player)] > 0) return false;
          if (player === 'white') {
            for (let p = 1; p <= 18; p++) { if (board[p] > 0) return false; }
          } else {
            for (let p = 7; p <= 24; p++) { if (board[p] < 0) return false; }
          }
          return true;
        }
        function applyMove(board, move, player) {
          const { from, to } = move;
          if (from === 'bar') { board[barIdx(player)]--; }
          else { board[from] += player === 'white' ? -1 : 1; }
          if (to === 'off') return;
          const dest = board[to];
          const isBlot = (player === 'white' && dest === -1) || (player === 'black' && dest === 1);
          if (isBlot) {
            const opp = player === 'white' ? 'black' : 'white';
            board[barIdx(opp)]++;
            board[to] = 0;
          }
          board[to] += player === 'white' ? 1 : -1;
        }
        function calcMoves(board, player, dice) {
          const dir = moveDir(player);
          const unique = [...new Set(dice)];
          const moves = [];
          const bi = barIdx(player);
          if (board[bi] > 0) {
            for (const dv of unique) {
              const entry = player === 'white' ? dv : 25 - dv;
              if (canLand(board, entry, player)) {
                moves.push({ from: 'bar', to: entry, dieValue: dv });
              }
            }
            return moves;
          }
          const bearingOff = canBearOff(board, player);
          for (let p = 1; p <= 24; p++) {
            if (!ownsPoint(board, p, player)) continue;
            for (const dv of unique) {
              const dest = p + dir * dv;
              if (dest >= 1 && dest <= 24 && canLand(board, dest, player)) {
                moves.push({ from: p, to: dest, dieValue: dv });
              } else if (bearingOff && (dest < 1 || dest > 24)) {
                if (player === 'white' && dest === 25) {
                  moves.push({ from: p, to: 'off', dieValue: dv });
                } else if (player === 'black' && dest === 0) {
                  moves.push({ from: p, to: 'off', dieValue: dv });
                } else {
                  let isFurthest = true;
                  if (player === 'white') {
                    for (let q = 19; q < p; q++) { if (board[q] > 0) { isFurthest = false; break; } }
                  } else {
                    for (let q = 6; q > p; q--) { if (board[q] < 0) { isFurthest = false; break; } }
                  }
                  if (isFurthest) moves.push({ from: p, to: 'off', dieValue: dv });
                }
              }
            }
          }
          return moves;
        }
        function filterMaxUsage(candidates, board, player, remaining) {
          if (remaining.length <= 1) return candidates;
          if (new Set(remaining).size === 1) return candidates;
          const useBoth = [];
          const byDie = {};
          for (const move of candidates) {
            const bCopy = [...board];
            applyMove(bCopy, move, player);
            const rest = [...remaining];
            rest.splice(rest.indexOf(move.dieValue), 1);
            const secondMoves = calcMoves(bCopy, player, rest);
            if (secondMoves.length > 0) useBoth.push(move);
            if (!byDie[move.dieValue]) byDie[move.dieValue] = [];
            byDie[move.dieValue].push(move);
          }
          if (useBoth.length > 0) return useBoth;
          const sorted = [...new Set(remaining)].sort((a, b) => b - a);
          for (const dv of sorted) {
            if (byDie[dv] && byDie[dv].length > 0) return byDie[dv];
          }
          return [];
        }
        function generateAllSequences(board, player, remaining) {
          const sequences = [];
          function recurse(curBoard, curRemaining, curMoves) {
            const raw = calcMoves(curBoard, player, curRemaining);
            const filtered = filterMaxUsage(raw, curBoard, player, curRemaining);
            if (filtered.length === 0) {
              if (curMoves.length > 0) {
                sequences.push({ moves: [...curMoves], resultBoard: [...curBoard] });
              }
              return;
            }
            const seen = new Set();
            for (const move of filtered) {
              const key = move.from + '-' + move.to + '-' + move.dieValue;
              if (seen.has(key)) continue;
              seen.add(key);
              const nextBoard = [...curBoard];
              applyMove(nextBoard, move, player);
              const nextRemaining = [...curRemaining];
              nextRemaining.splice(nextRemaining.indexOf(move.dieValue), 1);
              curMoves.push(move);
              recurse(nextBoard, nextRemaining, curMoves);
              curMoves.pop();
            }
          }
          recurse([...board], [...remaining], []);
          if (sequences.length === 0) {
            sequences.push({ moves: [], resultBoard: [...board] });
          }
          return sequences;
        }
        function pipCount(board, player) {
          let count = 0;
          if (player === 'white') {
            count += board[0] * 25;
            for (let p = 1; p <= 24; p++) { if (board[p] > 0) count += board[p] * (25 - p); }
          } else {
            count += board[25] * 25;
            for (let p = 1; p <= 24; p++) { if (board[p] < 0) count += Math.abs(board[p]) * p; }
          }
          return count;
        }
        function countOwnedPoints(board, player) {
          let n = 0;
          for (let p = 1; p <= 24; p++) {
            if (player === 'white' && board[p] >= 2) n++;
            if (player === 'black' && board[p] <= -2) n++;
          }
          return n;
        }
        function countBlots(board, player) {
          let n = 0;
          for (let p = 1; p <= 24; p++) {
            if (player === 'white' && board[p] === 1) n++;
            if (player === 'black' && board[p] === -1) n++;
          }
          return n;
        }
        function longestPrime(board, player) {
          let best = 0, run = 0;
          for (let p = 1; p <= 24; p++) {
            if ((player === 'white' && board[p] >= 2) || (player === 'black' && board[p] <= -2)) {
              run++;
              if (run > best) best = run;
            } else { run = 0; }
          }
          return best;
        }
        function hasContact(board) {
          if (board[0] > 0) return true;
          if (board[25] > 0) return true;
          let whiteRear = 25;
          for (let p = 1; p <= 24; p++) { if (board[p] > 0) { whiteRear = p; break; } }
          let blackRear = 0;
          for (let p = 24; p >= 1; p--) { if (board[p] < 0) { blackRear = p; break; } }
          return whiteRear <= blackRear;
        }
        function homeBoardStrength(board, player) {
          let n = 0;
          if (player === 'black') {
            for (let p = 1; p <= 6; p++) { if (board[p] <= -2) n++; }
          } else {
            for (let p = 19; p <= 24; p++) { if (board[p] >= 2) n++; }
          }
          return n;
        }
        function countBorneOff(board, player) {
          let onBoard = 0;
          const bar = player === 'white' ? 0 : 25;
          onBoard += board[bar];
          for (let p = 1; p <= 24; p++) {
            if (player === 'white' && board[p] > 0) onBoard += board[p];
            if (player === 'black' && board[p] < 0) onBoard += Math.abs(board[p]);
          }
          return 15 - onBoard;
        }

        // ══════════════════════════════════════════
        // PROFESSIONAL AI LOGIC
        // ══════════════════════════════════════════

        // 21 distinct dice outcomes with frequencies (out of 36)
        const DICE_OUTCOMES = [
          {d:[1,1],w:1},{d:[2,2],w:1},{d:[3,3],w:1},{d:[4,4],w:1},{d:[5,5],w:1},{d:[6,6],w:1},
          {d:[1,2],w:2},{d:[1,3],w:2},{d:[1,4],w:2},{d:[1,5],w:2},{d:[1,6],w:2},
          {d:[2,3],w:2},{d:[2,4],w:2},{d:[2,5],w:2},{d:[2,6],w:2},
          {d:[3,4],w:2},{d:[3,5],w:2},{d:[3,6],w:2},
          {d:[4,5],w:2},{d:[4,6],w:2},
          {d:[5,6],w:2}
        ];

        function randomDice() {
          const d1 = Math.floor(Math.random() * 6) + 1;
          const d2 = Math.floor(Math.random() * 6) + 1;
          return d1 === d2 ? [d1, d1, d1, d1] : [d1, d2];
        }

        // ── Position Classification ──
        function classifyProPosition(board, player) {
          // BEAROFF: all checkers in home board, no contact
          const bar = player === 'white' ? 0 : 25;
          if (board[bar] > 0) {
            // On bar — definitely contact/survival
            return hasContact(board) ? 'CONTACT' : 'CONTACT';
          }
          const allHome = canBearOff(board, player);
          if (allHome && !hasContact(board)) return 'BEAROFF';
          if (!hasContact(board)) return 'SEMI-RACE';
          return 'CONTACT';
        }

        // ── Bearoff Evaluation ──
        function bearoffScore(board, player) {
          // Minimize: pip count + wastage * 1.5
          const pips = pipCount(board, player);
          let wastage = 0;
          if (player === 'black') {
            // Black home = points 1-6
            for (let p = 1; p <= 6; p++) {
              if (board[p] < 0) {
                const count = Math.abs(board[p]);
                // Stacking penalty: checkers beyond 2 on low points waste pips
                if (count > 2 && p <= 3) {
                  wastage += (count - 2) * (4 - p); // lower point = more waste
                }
                // Penalize gaps — checkers on high points with nothing below
                if (p >= 4 && count > 0) {
                  let belowEmpty = true;
                  for (let q = 1; q < p; q++) {
                    if (board[q] < 0) { belowEmpty = false; break; }
                  }
                  if (belowEmpty) wastage += count * 0.5;
                }
              }
            }
          } else {
            // White home = points 19-24
            for (let p = 19; p <= 24; p++) {
              if (board[p] > 0) {
                const count = board[p];
                if (count > 2 && p >= 22) {
                  wastage += (count - 2) * (p - 21);
                }
                if (p <= 21 && count > 0) {
                  let aboveEmpty = true;
                  for (let q = p + 1; q <= 24; q++) {
                    if (board[q] > 0) { aboveEmpty = false; break; }
                  }
                  if (aboveEmpty) wastage += count * 0.5;
                }
              }
            }
          }
          // Lower is better — negate for scoring (higher = better)
          return -(pips + wastage * 1.5);
        }

        // ── Equity Estimation ──
        function estimateEquity(board, player) {
          const opp = player === 'white' ? 'black' : 'white';
          let equity = 0;

          // Race features
          const myPip = pipCount(board, player);
          const oppPip = pipCount(board, opp);
          equity += (oppPip - myPip) * 0.01;

          // Distribution: penalize stacks of 4+
          for (let p = 1; p <= 24; p++) {
            const val = player === 'black' ? board[p] : board[p];
            const count = player === 'black' ? (board[p] < 0 ? Math.abs(board[p]) : 0) : (board[p] > 0 ? board[p] : 0);
            if (count >= 4) equity -= (count - 3) * 0.05;
          }

          // Bearoff progress
          const borneOff = countBorneOff(board, player);
          equity += borneOff * 0.08;

          // Contact features
          const contact = hasContact(board);
          if (contact) {
            // Home board strength
            const hbs = homeBoardStrength(board, player);
            equity += hbs * 0.12;

            // Prime score
            const prime = longestPrime(board, player);
            equity += prime * 0.08;

            // Anchor value (made points in opponent home)
            if (player === 'black') {
              for (let p = 19; p <= 24; p++) {
                if (board[p] <= -2) equity += 0.10;
              }
            } else {
              for (let p = 1; p <= 6; p++) {
                if (board[p] >= 2) equity += 0.10;
              }
            }

            // Attack presence: checkers in opponent home
            if (player === 'black') {
              for (let p = 19; p <= 24; p++) {
                if (board[p] < 0) equity += Math.abs(board[p]) * 0.04;
              }
            } else {
              for (let p = 1; p <= 6; p++) {
                if (board[p] > 0) equity += board[p] * 0.04;
              }
            }

            // Blots given (own exposed blots)
            equity += countBlots(board, player) * -0.09;

            // Opponent blots
            equity += countBlots(board, opp) * 0.06;

            // Containment: opponent on bar
            const oppBar = opp === 'white' ? 0 : 25;
            equity += board[oppBar] * 0.15;

            // Gammon logic
            const oppHbs = homeBoardStrength(board, opp);
            if (myPip < oppPip - 40 && hbs >= 3) {
              equity += 0.20; // pursue gammon
            }
            if (oppPip < myPip - 40 && oppHbs >= 3) {
              equity -= 0.20; // survival penalty
            }
          }

          return equity;
        }

        // ── Intermediate-level AI for rollout playout ──
        function intermediateChooseBest(sequences, board) {
          if (sequences.length === 0) return null;
          if (sequences.length === 1) return sequences[0];

          let best = null;
          let bestScore = -Infinity;
          for (const seq of sequences) {
            const rb = seq.resultBoard;
            // Quick heuristic scoring
            let score = 0;
            // Hits
            score += (rb[0] - board[0]) * 35; // white bar increase (for black player)
            // Use estimateEquity for the player who just moved
            score += estimateEquity(rb, seq._player || 'black') * 100;
            if (score > bestScore) { bestScore = score; best = seq; }
          }
          return best || sequences[0];
        }

        // ── Rollout: simulate games from a position ──
        function rolloutFromPosition(board, player, numGames, timeLimit) {
          const startTime = Date.now();
          let wins = 0;
          let gamesPlayed = 0;
          const opp = player === 'white' ? 'black' : 'white';

          for (let g = 0; g < numGames; g++) {
            // Time check every 10 games
            if (g > 0 && g % 10 === 0) {
              if (Date.now() - startTime > timeLimit) break;
            }

            const b = [...board];
            let borneOff = { white: countBorneOff(b, 'white'), black: countBorneOff(b, 'black') };
            let current = opp; // opponent moves next after our candidate play
            let moveCount = 0;
            const MAX_MOVES = 200; // safety cap

            while (moveCount < MAX_MOVES) {
              moveCount++;
              const dice = randomDice();
              const seqs = generateAllSequences(b, current, dice);

              // Choose best move using intermediate-level logic
              if (seqs.length > 0 && seqs[0].moves.length > 0) {
                // Quick scoring: pick best by equity
                let bestSeq = seqs[0];
                let bestEq = -Infinity;
                // Cap sequences to evaluate for speed
                const evalLimit = Math.min(seqs.length, 20);
                for (let i = 0; i < evalLimit; i++) {
                  const eq = estimateEquity(seqs[i].resultBoard, current);
                  if (eq > bestEq) { bestEq = eq; bestSeq = seqs[i]; }
                }
                // Apply the chosen sequence to the board
                for (let p = 0; p < 26; p++) b[p] = bestSeq.resultBoard[p];
              }

              // Update borne off counts
              borneOff.white = countBorneOff(b, 'white');
              borneOff.black = countBorneOff(b, 'black');

              // Check for win
              if (borneOff[current] >= 15) {
                if (current === player) wins++;
                break;
              }

              // Switch player
              current = current === 'white' ? 'black' : 'white';
            }

            gamesPlayed++;
          }

          return { wins, losses: gamesPlayed - wins, gamesPlayed };
        }

        // ── Main message handler ──
        self.onmessage = function(e) {
          const { type, id } = e.data;

          if (type === 'professional') {
            const { candidates, player, mode, rolloutGames, timeBudgetMs } = e.data;
            const startTime = Date.now();
            const results = [];

            if (mode === 'BEAROFF') {
              // Pure bearoff: score by pip+wastage, no rollout needed
              for (let i = 0; i < candidates.length; i++) {
                results.push({
                  index: i,
                  equity: bearoffScore(candidates[i].resultBoard, player),
                  rolloutGames: 0,
                  keyFactors: 'bearoff efficiency'
                });
              }
              self.postMessage({ type: 'professional', results, id });
              return;
            }

            // CONTACT or SEMI-RACE: equity estimate + rollout for top 3
            // Step 1: Score all candidates with equity estimation
            const scored = candidates.map((c, i) => ({
              index: i,
              equity: estimateEquity(c.resultBoard, player),
              resultBoard: c.resultBoard
            }));
            scored.sort((a, b) => b.equity - a.equity);

            // Step 2: Rollout top 3
            const rolloutCount = Math.min(3, scored.length);
            const timePerCandidate = Math.floor((timeBudgetMs - (Date.now() - startTime)) / rolloutCount);
            let actualGames = rolloutGames;

            for (let i = 0; i < scored.length; i++) {
              const c = scored[i];

              if (i < rolloutCount) {
                // Determine time limit for this rollout
                const timeLeft = timeBudgetMs - (Date.now() - startTime);
                const timeForThis = Math.min(timePerCandidate, timeLeft - 100);

                if (timeForThis < 50) {
                  // No time left, use static equity
                  results.push({
                    index: c.index,
                    equity: c.equity,
                    rolloutGames: 0,
                    keyFactors: identifyKeyFactors(c.resultBoard, player)
                  });
                  continue;
                }

                // Adaptive game count
                let games = actualGames;
                if (timeLeft < 1500) games = Math.min(games, 75);

                const ro = rolloutFromPosition(c.resultBoard, player, games, timeForThis);
                const rolloutEquity = ro.gamesPlayed > 0
                  ? (ro.wins - ro.losses) / ro.gamesPlayed
                  : c.equity;

                // Blend static and rollout: 30% static + 70% rollout
                const blended = c.equity * 0.3 + rolloutEquity * 0.7;

                results.push({
                  index: c.index,
                  equity: blended,
                  rolloutGames: ro.gamesPlayed,
                  keyFactors: identifyKeyFactors(c.resultBoard, player)
                });

                // Check if rollout was cut short — reduce for subsequent
                if (ro.gamesPlayed < games * 0.8) {
                  actualGames = Math.max(50, Math.floor(actualGames * 0.5));
                }
              } else {
                // Non-rollout candidates keep static equity
                results.push({
                  index: c.index,
                  equity: c.equity,
                  rolloutGames: 0,
                  keyFactors: identifyKeyFactors(c.resultBoard, player)
                });
              }
            }

            self.postMessage({ type: 'professional', results, id });
          }
        };

        // ── Identify key factors for logging ──
        function identifyKeyFactors(board, player) {
          const factors = [];
          const opp = player === 'white' ? 'black' : 'white';
          const hbs = homeBoardStrength(board, player);
          const prime = longestPrime(board, player);
          const oppBar = opp === 'white' ? 0 : 25;

          if (hbs >= 3) factors.push('home board strength');
          if (prime >= 3) factors.push('prime extension');
          if (board[oppBar] > 0) factors.push('containment');
          if (countBlots(board, player) === 0) factors.push('no blots');
          if (countBlots(board, opp) >= 2) factors.push('attacking blots');

          const myPip = pipCount(board, player);
          const oppPip = pipCount(board, opp);
          if (oppPip - myPip > 20) factors.push('pip lead');
          if (myPip - oppPip > 20) factors.push('pip deficit');

          if (player === 'black') {
            for (let p = 19; p <= 24; p++) {
              if (board[p] <= -2) { factors.push('anchor'); break; }
            }
          }

          return factors.length > 0 ? factors.slice(0, 3).join(', ') : 'balanced position';
        }
      `;

      try {
        const blob = new Blob([workerCode], { type: 'application/javascript' });
        const url = URL.createObjectURL(blob);
        proWorker = new Worker(url);
        proWorkerReady = true;
        URL.revokeObjectURL(url);
        console.log('[AI-PRO] Web Worker created successfully');
      } catch (e) {
        console.warn('[AI-PRO] Web Worker creation failed:', e.message);
        proWorkerReady = false;
      }
    }

    // Initialize pro worker on load
    createProWorker();

    let proWorkerMsgId = 0;

    /** Send candidates to Professional Worker for rollout evaluation. Returns Promise. */
    function computeProfessionalEval(candidates, player, mode) {
      const rolloutGames = 150;
      const timeBudgetMs = 2800; // leave 200ms margin from 3s target

      if (!proWorkerReady || !proWorker) {
        // Synchronous fallback: use equity estimation only (no rollout)
        return Promise.resolve(computeProfessionalSync(candidates, player, mode));
      }

      const msgId = ++proWorkerMsgId;

      return Promise.race([
        new Promise((resolve) => {
          const handler = (e) => {
            if (e.data.type === 'professional' && e.data.id === msgId) {
              proWorker.removeEventListener('message', handler);
              resolve(e.data.results);
            }
          };
          proWorker.addEventListener('message', handler);

          proWorker.postMessage({
            type: 'professional',
            candidates: candidates.map((c, i) => ({
              index: i,
              resultBoard: c.resultBoard
            })),
            player,
            mode,
            rolloutGames,
            timeBudgetMs,
            id: msgId
          });
        }),
        // 4-second hard timeout (worker has 2.8s budget, give extra margin)
        new Promise((resolve) => {
          setTimeout(() => {
            console.warn('[AI-PRO] Worker timeout — using static equity only');
            resolve(computeProfessionalSync(candidates, player, mode));
          }, 4000);
        })
      ]);
    }

    /** Synchronous fallback for professional evaluation (no rollout). */
    function computeProfessionalSync(candidates, player, mode) {
      return candidates.map((cand, i) => ({
        index: i,
        equity: estimateEquityMain(cand.resultBoard, player, mode),
        rolloutGames: 0,
        keyFactors: 'static eval (fallback)'
      }));
    }

    /** Main-thread equity estimation (mirrors worker logic). */
    function estimateEquityMain(board, player, mode) {
      if (mode === 'BEAROFF') {
        return bearoffScoreMain(board, player);
      }
      const opp = player === 'white' ? 'black' : 'white';
      let equity = 0;

      // Race features
      equity += (pipCount(board, opp) - pipCount(board, player)) * 0.01;

      // Distribution penalty
      for (let p = 1; p <= 24; p++) {
        const count = player === 'black' ? (board[p] < 0 ? Math.abs(board[p]) : 0) : (board[p] > 0 ? board[p] : 0);
        if (count >= 4) equity -= (count - 3) * 0.05;
      }

      // Bearoff progress
      equity += countBorneOff(board, player) * 0.08;

      if (hasContact(board)) {
        equity += homeBoardStrength(board, player) * 0.12;
        equity += longestPrime(board, player) * 0.08;
        equity += countAnchors(board, player) * 0.10;
        equity += countBlots(board, player) * -0.09;
        equity += countBlots(board, opp) * 0.06;
        const oppBar = opp === 'white' ? 0 : 25;
        equity += board[oppBar] * 0.15;
      }

      return equity;
    }

    /** Main-thread bearoff scoring. */
    function bearoffScoreMain(board, player) {
      const pips = pipCount(board, player);
      let wastage = 0;
      if (player === 'black') {
        for (let p = 1; p <= 6; p++) {
          if (board[p] < 0) {
            const count = Math.abs(board[p]);
            if (count > 2 && p <= 3) wastage += (count - 2) * (4 - p);
          }
        }
      }
      return -(pips + wastage * 1.5);
    }

    /** Classify position for Professional AI. */
    function classifyProPosition(board, player) {
      const bar = player === 'white' ? 0 : 25;
      if (board[bar] > 0) return 'CONTACT';
      if (canBearOff(board, player) && !hasContact(board)) return 'BEAROFF';
      if (!hasContact(board)) return 'SEMI-RACE';
      return 'CONTACT';
    }

    /** Professional AI: estimate win probability from equity. */
    function proEstimateWinProb(board, player) {
      const equity = estimateEquityMain(board, player, classifyProPosition(board, player));
      return Math.max(0.05, Math.min(0.95, 0.5 + equity * 0.35));
    }

    // ════════════════════════════════════════════════
    //  AI — Professional (rollout chooser)
    // ════════════════════════════════════════════════

    async function aiProfessionalChooseSequence(sequences, originalBoard) {
      if (sequences.length <= 1) return sequences[0] || null;

      const player = 'black';
      const mode = classifyProPosition(originalBoard, player);

      // Prepare candidates with result boards
      const candidates = sequences.map((seq, idx) => ({
        seq,
        index: idx,
        resultBoard: seq.resultBoard
      }));

      // Send to Professional Worker
      let results;
      try {
        results = await computeProfessionalEval(candidates, player, mode);
      } catch (e) {
        console.warn('[AI-PRO] Evaluation failed:', e.message);
        results = computeProfessionalSync(candidates, player, mode);
      }

      // Map results back and find best
      const resultMap = {};
      for (const r of results) {
        resultMap[r.index] = r;
      }

      let bestIdx = 0;
      let bestEquity = -Infinity;
      let bestResult = null;
      let totalRolloutGames = 0;

      for (const r of results) {
        if (r.equity > bestEquity) {
          bestEquity = r.equity;
          bestIdx = r.index;
          bestResult = r;
        }
        totalRolloutGames = Math.max(totalRolloutGames, r.rolloutGames || 0);
      }

      const chosen = candidates[bestIdx];

      // Console log
      const roll = G.dice.values || [0, 0];
      const playStr = chosen.seq.moves.length > 0
        ? chosen.seq.moves.map(m => `${m.from === 'bar' ? 'bar' : m.from}→${m.to === 'off' ? 'off' : m.to}`).join(', ')
        : 'No moves';
      const factors = bestResult ? bestResult.keyFactors : 'unknown';

      console.log(
        `[AI-PRO] Roll: ${roll[0]}-${roll[1]} | Mode: ${mode} | ` +
        `Candidates: ${Math.min(3, candidates.length)} | ` +
        `Rollout games: ${totalRolloutGames} | ` +
        `Best play: ${playStr} | ` +
        `Equity: ${bestEquity >= 0 ? '+' : ''}${bestEquity.toFixed(2)} | ` +
        `Key factors: ${factors}`
      );

      return chosen.seq;
    }

    // ════════════════════════════════════════════════
    //  AI — Choose best move sequence based on difficulty
    // ════════════════════════════════════════════════

    async function aiChooseMoveSequence() {
      const sequences = generateAllSequences(G.board, 'black', G.dice.remaining);

      if (sequences.length === 0 || (sequences.length === 1 && sequences[0].moves.length === 0)) {
        return [];
      }

      let chosen;
      const originalBoard = [...G.board];

      switch (G.aiDifficulty) {
        case 'beginner':
          chosen = aiBeginnerChooseSequence(sequences, originalBoard);
          break;
        case 'intermediate':
          chosen = await aiIntermediateChooseSequence(sequences, originalBoard);
          break;
        case 'advanced':
          chosen = await aiProfessionalChooseSequence(sequences, originalBoard);
          break;
        default:
          chosen = await aiIntermediateChooseSequence(sequences, originalBoard);
      }

      return chosen ? chosen.moves : [];
    }

    // ════════════════════════════════════════════════
    //  AI — Doubling Cube Decision
    // ════════════════════════════════════════════════

    /** Should AI offer a double? */
    function aiShouldDouble() {
      if (!G.cube.enabled) return false;
      const canDouble = G.cube.owner === null || G.cube.owner === 'black';
      const nextValue = G.cube.value * 2;
      if (!canDouble || nextValue > G.cube.maxValue) return false;

      const myPip = pipCount(G.board, 'black');
      const oppPip = pipCount(G.board, 'white');
      const pipDiff = oppPip - myPip; // positive means we're ahead

      switch (G.aiDifficulty) {
        case 'beginner':
          // Random — rarely doubles
          return Math.random() < 0.08;

        case 'intermediate':
          // Double if we're ahead by 15+ pips
          return pipDiff >= 15;

        case 'advanced': {
          // Professional: equity-based cube decision
          const winProb = proEstimateWinProb(G.board, 'black');
          const oppWinProb = 1 - winProb;
          // Offer double if win probability > 68% AND opponent still has reason to accept (>22%)
          return winProb > 0.68 && oppWinProb > 0.22;
        }

        default:
          return false;
      }
    }

    /** Should AI accept a double? */
    function aiShouldAcceptDouble() {
      const myPip = pipCount(G.board, 'black');
      const oppPip = pipCount(G.board, 'white');
      const pipDiff = myPip - oppPip; // positive means we're behind

      switch (G.aiDifficulty) {
        case 'beginner':
          // Random accept/decline
          return Math.random() < 0.5;

        case 'intermediate':
          // Accept if pip count is roughly even or in our favor
          return pipDiff <= 20;

        case 'advanced': {
          // Professional: equity-based cube acceptance
          const winProb = proEstimateWinProb(G.board, 'black');
          // Accept if win probability > 22%
          return winProb > 0.22;
        }

        default:
          return pipDiff <= 20;
      }
    }

    // ════════════════════════════════════════════════
    //  AI — Turn Orchestration
    // ════════════════════════════════════════════════

    function clearAITimers() {
      for (const t of G.aiTimers) {
        clearTimeout(t);
      }
      G.aiTimers = [];
    }

    function showAIThinking(show) {
      G.aiThinking = show;
      document.getElementById('aiThinking').classList.toggle('visible', show);
    }

    /** Get a random AI delay between 0.8 and 1.2 seconds. */
    function aiDelay() {
      return 800 + Math.random() * 400;
    }

    /**
     * Main AI turn handler. Called when it's the AI's turn to act.
     * Handles: rolling, moving, doubling.
     */
    function aiTakeTurn() {
      if (!isAITurn()) return;

      if (G.phase === Phase.ROLLING) {
        // First, consider doubling
        if (aiShouldDouble()) {
          showAIThinking(true);
          const t = setTimeout(() => {
            showAIThinking(false);
            aiOfferDouble();
          }, aiDelay());
          G.aiTimers.push(t);
          return;
        }

        // Otherwise, roll dice
        showAIThinking(true);
        G.message = `${pName('black')}'s turn...`;
        renderBoard();

        const t = setTimeout(() => {
          showAIThinking(false);
          aiRollDice();
        }, aiDelay());
        G.aiTimers.push(t);
      }
    }

    function aiRollDice() {
      if (G.phase !== Phase.ROLLING) return;

      // Simulate rolling
      const d1 = document.getElementById('die1');
      const d2 = document.getElementById('die2');
      d1.classList.remove('used');
      d2.classList.remove('used');
      d1.querySelector('.doubles-badge')?.remove();
      d2.querySelector('.doubles-badge')?.remove();
      d1.classList.add('rolling');
      d2.classList.add('rolling');

      playDiceSound();

      setTimeout(() => {
        const v1 = Math.floor(Math.random() * 6) + 1;
        const v2 = Math.floor(Math.random() * 6) + 1;

        renderDieFace(document.getElementById('dieFace1'), v1);
        renderDieFace(document.getElementById('dieFace2'), v2);

        d1.classList.remove('rolling');
        d2.classList.remove('rolling');

        G.dice.values = [v1, v2];
        if (v1 === v2) {
          G.dice.remaining = [v1, v1, v1, v1];
        } else {
          G.dice.remaining = [v1, v2];
        }

        G.phase = Phase.MOVING;
        G.undoStack = [];
        G.allLegalMoves = calculateAllLegalMoves();

        if (G.allLegalMoves.length === 0) {
          G.message = `${pName('black')} rolled ${v1} and ${v2} — no legal moves!`;
          renderBoard();
          const t = setTimeout(endTurn, 1500);
          G.aiTimers.push(t);
        } else {
          const doublesNote = v1 === v2 ? ' (doubles — 4 moves!)' : '';
          G.message = `${pName('black')} rolled ${v1} and ${v2}${doublesNote}`;
          renderBoard();

          // Plan and execute AI moves
          aiExecuteMoves();
        }
      }, 400);
    }

    async function aiExecuteMoves() {
      const moves = await aiChooseMoveSequence();

      if (moves.length === 0) {
        G.message = `${pName('black')} has no legal moves!`;
        renderBoard();
        const t = setTimeout(endTurn, 1500);
        G.aiTimers.push(t);
        return;
      }

      showAIThinking(true);

      // Execute moves one by one with delays
      let i = 0;

      function doNextMove() {
        if (i >= moves.length || G.phase !== Phase.MOVING) {
          showAIThinking(false);
          return;
        }

        const move = moves[i];
        i++;

        // Validate that this move is still legal
        const legal = G.allLegalMoves.find(m => m.from === move.from && m.to === move.to && m.dieValue === move.dieValue);
        if (!legal) {
          // Move no longer valid (board state changed) — try to recalculate
          showAIThinking(false);
          // Recalculate remaining moves
          if (G.dice.remaining.length > 0 && G.allLegalMoves.length > 0) {
            aiExecuteMoves(); // restart with fresh sequence
          } else if (G.dice.remaining.length === 0 || G.allLegalMoves.length === 0) {
            G.message = `${pName('black')}'s turn complete.`;
            renderBoard();
            const t = setTimeout(endTurn, 600);
            G.aiTimers.push(t);
          }
          return;
        }

        executeMove(move);

        // Check if game ended (win) or turn already ended by executeMove -> startGracePeriod
        if (G.phase === Phase.GAME_OVER || G.phase === Phase.ROLLING) {
          showAIThinking(false);
          return;
        }

        // Check if more moves needed
        if (G.dice.remaining.length > 0 && G.allLegalMoves.length > 0 && i < moves.length) {
          const t = setTimeout(doNextMove, aiDelay());
          G.aiTimers.push(t);
        } else {
          // Done moving — grace period / end turn already handled by executeMove
          showAIThinking(false);
        }
      }

      const t = setTimeout(doNextMove, aiDelay());
      G.aiTimers.push(t);
    }

    function aiOfferDouble() {
      // AI offers a double
      handleDouble();
    }

    /**
     * AI responds to a double offer (when human doubles the AI).
     */
    function aiRespondToDouble() {
      showAIThinking(true);

      const t = setTimeout(() => {
        showAIThinking(false);

        if (aiShouldAcceptDouble()) {
          handleAcceptDouble();
        } else {
          handleDeclineDouble();
        }
      }, aiDelay() + 200);
      G.aiTimers.push(t);
    }

    // ════════════════════════════════════════════════
    //  RENDERING — Dice
    // ════════════════════════════════════════════════

    function renderDieFace(el, value) {
      el.innerHTML = '';
      for (const pos of PIP_LAYOUTS[value]) {
        const pip = document.createElement('span');
        pip.className = `pip ${pos}`;
        el.appendChild(pip);
      }
    }

    function renderDice() {
      const d1 = document.getElementById('die1');
      const d2 = document.getElementById('die2');
      const f1 = document.getElementById('dieFace1');
      const f2 = document.getElementById('dieFace2');
      const { values, remaining } = G.dice;

      d1.querySelector('.doubles-badge')?.remove();
      d2.querySelector('.doubles-badge')?.remove();

      if (values.length === 0) {
        d1.classList.remove('used');
        d2.classList.remove('used');
        renderDieFace(f1, 1);
        renderDieFace(f2, 1);
        return;
      }

      const isDoubles = values[0] === values[1];

      if (isDoubles) {
        renderDieFace(f1, values[0]);
        renderDieFace(f2, values[0]);

        const used = values.length === 4
          ? 4 - remaining.length
          : 2 - remaining.length;

        if (values.length === 4) {
          d1.classList.toggle('used', used >= 2);
          d2.classList.toggle('used', used >= 4);

          if (remaining.length > 0) {
            const badge = document.createElement('span');
            badge.className = 'doubles-badge';
            badge.textContent = remaining.length;
            d2.appendChild(badge);
          }
        } else {
          d1.classList.toggle('used', !remaining.includes(values[0]));
          d2.classList.toggle('used', remaining.length === 0);
        }
      } else {
        renderDieFace(f1, values[0]);
        renderDieFace(f2, values[1]);

        const rem = [...remaining];
        let die1Used = true;
        let die2Used = true;

        const idx0 = rem.indexOf(values[0]);
        if (idx0 !== -1) {
          die1Used = false;
          rem.splice(idx0, 1);
        }
        const idx1 = rem.indexOf(values[1]);
        if (idx1 !== -1) {
          die2Used = false;
        }

        d1.classList.toggle('used', die1Used);
        d2.classList.toggle('used', die2Used);
      }
    }

    // ════════════════════════════════════════════════
    //  RENDERING — Status message
    // ════════════════════════════════════════════════

    function renderStatus() {
      const bar = document.getElementById('statusBar');
      if (G.phase === Phase.MODE_SELECT) {
        bar.innerHTML = 'Choose a game mode to begin.';
        return;
      }

      let html = '';
      if (G.phase !== Phase.OPENING_ROLL) {
        html += `<span class="turn-indicator ${G.currentPlayer}"></span>`;
      }
      html += G.message;
      bar.innerHTML = html;
    }

    // ════════════════════════════════════════════════
    //  RENDERING — Scoreboard
    // ════════════════════════════════════════════════

    function renderScoreboard() {
      const el = document.getElementById('scoreboard');
      const visible = G.phase !== Phase.MODE_SELECT;
      el.classList.toggle('visible', visible);

      if (visible) {
        document.getElementById('scoreWhite').textContent = G.score.white;
        document.getElementById('scoreBlack').textContent = G.score.black;
        document.getElementById('scoreWhiteName').textContent = pName('white');
        document.getElementById('scoreBlackName').textContent = pName('black');
      }
    }

    // ════════════════════════════════════════════════
    //  RENDERING — Cube Display
    // ════════════════════════════════════════════════

    function renderCubeDisplay() {
      const el = document.getElementById('cubeDisplay');
      const visible = G.cube.enabled && G.phase !== Phase.MODE_SELECT && G.phase !== Phase.GAME_OVER;
      el.classList.toggle('visible', visible);

      // Position cube based on owner
      el.classList.remove('owner-white', 'owner-black', 'owner-center');
      if (G.cube.owner === 'white') el.classList.add('owner-white');
      else if (G.cube.owner === 'black') el.classList.add('owner-black');
      else el.classList.add('owner-center');

      if (visible) {
        document.getElementById('cubeValue').textContent = G.cube.value;
        const ownerLabel = document.getElementById('cubeOwnerLabel');
        if (G.cube.owner === null) {
          ownerLabel.textContent = 'Center';
        } else {
          ownerLabel.textContent = pName(G.cube.owner) + ' owns';
        }
      }
    }

    // ════════════════════════════════════════════════
    //  RENDERING — Bear-off trays
    // ════════════════════════════════════════════════

    function renderBearOffTrays() {
      for (const color of ['white', 'black']) {
        const tray = document.getElementById(color === 'white' ? 'trayWhite' : 'trayBlack');
        const countEl = document.getElementById(color === 'white' ? 'trayWhiteCount' : 'trayBlackCount');
        const checkersEl = document.getElementById(color === 'white' ? 'trayWhiteCheckers' : 'trayBlackCheckers');

        const count = G.borneOff[color];
        countEl.textContent = count;
        checkersEl.innerHTML = '';

        // Create checkers stacking vertically
        for (let i = 0; i < count; i++) {
          const c = document.createElement('div');
          c.className = `checker ${color}`;
          checkersEl.appendChild(c);
        }

        tray.classList.remove('valid-target');
        if (G.phase === Phase.MOVING && color === G.currentPlayer) {
          const hasBearOffMove = G.validMoves.some(m => m.to === 'off');
          if (hasBearOffMove) {
            tray.classList.add('valid-target');
          }
        }
      }
    }

    // ════════════════════════════════════════════════
    //  RENDERING — Checker Overlap (crowded points)
    // ════════════════════════════════════════════════

    /**
     * Apply negative margins to checkers so they always fit within
     * the quadrant's available height. Even 5 checkers may need
     * compression depending on viewport size.
     */
    function applyCheckerOverlap(checkersEl, checkerCount, pointEl) {
      const checkerEls = checkersEl.querySelectorAll('.checker');

      // Reset any previous overlap styles
      checkerEls.forEach(c => {
        c.style.marginTop = '';
        c.style.marginBottom = '';
        c.style.zIndex = '';
      });

      if (checkerCount <= 1) return;

      const quadrant = pointEl.closest('.quadrant');
      if (!quadrant) return;

      const availableHeight = quadrant.clientHeight - 4; // minus padding
      const firstChecker = checkerEls[0];
      if (!firstChecker) return;
      const checkerSize = firstChecker.offsetHeight;
      if (checkerSize === 0) return;

      // Total height if stacked with zero gap
      const normalHeight = checkerCount * checkerSize;
      if (normalHeight <= availableHeight) return; // Plenty of room, no overlap needed

      // Calculate stride so all checkers fit within available height:
      // totalHeight = checkerSize + (N-1) * stride = availableHeight
      // stride = (availableHeight - checkerSize) / (N - 1)
      const stride = Math.max(checkerSize * 0.2, (availableHeight - checkerSize) / (checkerCount - 1));
      const overlapAmount = checkerSize - stride;

      if (overlapAmount <= 0) return; // No overlap needed

      // Top quadrants stack down (column) → negative margin-top
      // Bottom quadrants stack up (column-reverse) → negative margin-bottom
      const isBottom = quadrant.classList.contains('bottom');
      const marginProp = isBottom ? 'marginBottom' : 'marginTop';

      checkerEls.forEach((c, i) => {
        // Ascending z-index: last checker (the interactive one) is on top
        c.style.zIndex = i + 1;
        if (i > 0) {
          c.style[marginProp] = `-${overlapAmount}px`;
        }
      });
    }

    /**
     * Overlap bar checkers when they don't fit in half the bar height.
     */
    function applyBarOverlap(barCheckersEl) {
      const checkerEls = barCheckersEl.querySelectorAll('.checker');
      checkerEls.forEach(c => {
        c.style.marginTop = '';
        c.style.zIndex = '';
      });

      if (checkerEls.length <= 1) return;

      const barEl = barCheckersEl.closest('.bar');
      if (!barEl) return;

      const availableHeight = (barEl.clientHeight / 2) - 8;
      const checkerSize = checkerEls[0]?.offsetHeight || 20;
      const totalNormal = checkerEls.length * checkerSize;

      if (totalNormal <= availableHeight) return;

      const stride = Math.max(checkerSize * 0.2, (availableHeight - checkerSize) / (checkerEls.length - 1));
      const overlap = checkerSize - stride;

      if (overlap <= 0) return;

      checkerEls.forEach((c, i) => {
        c.style.zIndex = i + 1;
        if (i > 0) {
          c.style.marginTop = `-${overlap}px`;
        }
      });
    }

    // ════════════════════════════════════════════════
    //  RENDERING — Board
    // ════════════════════════════════════════════════

    const BOARD_RATIO = 1.6; // width / height (landscape)

    function fitBoard() {
      const board = document.getElementById('board');
      const wrapper = document.querySelector('.board-wrapper');
      if (!board || !wrapper) return;
      // Use offsetWidth/Height (not getBoundingClientRect) because
      // ancestor transform:scale() doesn't affect layout dimensions.
      const availW = wrapper.offsetWidth;
      const availH = wrapper.offsetHeight;
      if (availW <= 0 || availH <= 0) return;
      // contain-fit: pick the largest size that fits within availW x availH at BOARD_RATIO
      let w, h;
      if (availW / availH > BOARD_RATIO) {
        h = availH;
        w = h * BOARD_RATIO;
      } else {
        w = availW;
        h = w / BOARD_RATIO;
      }
      board.style.width = Math.floor(w) + 'px';
      board.style.height = Math.floor(h) + 'px';
    }

    // ── Scale game-root to always fit the actual viewport ──
    const DESIGN_W = 1280;
    const DESIGN_H = 800;
    function scaleGame() {
      const scaleX = window.innerWidth / DESIGN_W;
      const scaleY = window.innerHeight / DESIGN_H;
      const scale = Math.min(scaleX, scaleY);
      const root = document.getElementById('game-root');
      if (!root) return;
      root.style.transform = 'scale(' + scale + ')';
      root.style.transformOrigin = 'top left';
      // Center the scaled root in the viewport
      root.style.left = ((window.innerWidth - DESIGN_W * scale) / 2) + 'px';
      root.style.top = ((window.innerHeight - DESIGN_H * scale) / 2) + 'px';
    }
    window.addEventListener('resize', function() {
      scaleGame();
      fitBoard();
    });
    scaleGame();

    function renderBoard() {
      // 1. Points 1-24
      for (let p = 1; p <= 24; p++) {
        const pointEl = document.querySelector(`.point[data-point="${p}"]`);
        if (!pointEl) continue;
        const checkersEl = pointEl.querySelector('.checkers');
        checkersEl.innerHTML = '';

        const count = G.board[p];
        const abs = Math.abs(count);
        const color = count > 0 ? 'white' : 'black';

        for (let i = 0; i < abs; i++) {
          const c = document.createElement('div');
          c.className = `checker ${color}`;
          checkersEl.appendChild(c);
        }

        // Apply overlap for crowded points
        applyCheckerOverlap(checkersEl, abs, pointEl);

        pointEl.classList.remove('selectable', 'selected', 'valid-target', 'combined-target');

        if (G.phase === Phase.MOVING) {
          if (G.allLegalMoves.some(m => m.from === p)) {
            pointEl.classList.add('selectable');
          }
          if (G.selectedPoint === p) {
            pointEl.classList.add('selected');
          }
          if (G.validMoves.some(m => m.to === p)) {
            pointEl.classList.add('valid-target');
          }
          if (G.combinedTargets.includes(p)) {
            pointEl.classList.add('combined-target');
          }
        }
      }

      // 2. Bar checkers
      const barWhite = document.getElementById('barWhite');
      const barBlack = document.getElementById('barBlack');
      if (barWhite && barBlack) {
        barWhite.innerHTML = '';
        barBlack.innerHTML = '';

        for (let i = 0; i < G.board[0]; i++) {
          const c = document.createElement('div');
          c.className = 'checker white';
          barWhite.appendChild(c);
        }
        for (let i = 0; i < G.board[25]; i++) {
          const c = document.createElement('div');
          c.className = 'checker black';
          barBlack.appendChild(c);
        }

        // Apply overlap for crowded bar
        applyBarOverlap(barWhite);
        applyBarOverlap(barBlack);

        const barEl = document.getElementById('barElement');
        barEl.classList.remove('selectable', 'selected');
        barWhite.classList.remove('active-bar');
        barBlack.classList.remove('active-bar');

        if (G.phase === Phase.MOVING) {
          const barMovesExist = G.allLegalMoves.some(m => m.from === 'bar');
          if (barMovesExist) {
            barEl.classList.add('selectable');
            if (G.currentPlayer === 'white') barWhite.classList.add('active-bar');
            else barBlack.classList.add('active-bar');
          }
          if (G.selectedPoint === 'bar') {
            barEl.classList.add('selected');
          }
        }
      }

      // 3. Bear-off trays
      renderBearOffTrays();

      // 4. Dice
      renderDice();

      // 5. Status
      renderStatus();

      // 6. Scoreboard
      renderScoreboard();

      // 7. Cube display
      renderCubeDisplay();

      // 8. Roll button — hide when not rolling phase OR when auto-roll is on OR when AI turn
      const rollBtn = document.getElementById('rollBtn');
      const aiTurn = isAITurn();
      rollBtn.classList.toggle('hidden', G.phase !== Phase.ROLLING || G.autoRoll || aiTurn);

      // 9. Double button — show during ROLLING phase when cube is enabled and player can double (not AI turn)
      const doubleBtn = document.getElementById('doubleBtn');
      let showDouble = false;
      if (G.cube.enabled && G.phase === Phase.ROLLING && !aiTurn) {
        const canDouble = G.cube.owner === null || G.cube.owner === G.currentPlayer;
        const nextValue = G.cube.value * 2;
        const withinMax = nextValue <= G.cube.maxValue;
        showDouble = canDouble && withinMax;
      }
      doubleBtn.classList.toggle('hidden', !showDouble);

      // 10. Undo button — show when moves have been made this turn (not AI turn)
      const undoBtn = document.getElementById('undoBtn');
      undoBtn.classList.toggle('hidden', G.undoStack.length === 0 || (G.phase !== Phase.MOVING) || aiTurn);

      // 11. Surrender button — show during active gameplay (not AI turn)
      const surrenderBtn = document.getElementById('surrenderBtn');
      const showSurrender = (G.phase === Phase.ROLLING || G.phase === Phase.MOVING) && !aiTurn;
      surrenderBtn.classList.toggle('hidden', !showSurrender);

      // 12. Toggle row visibility (harmless no-op on hidden shell)
      const toggleRow = document.getElementById('toggleRow');
      toggleRow.classList.toggle('visible', G.phase !== Phase.MODE_SELECT && G.phase !== Phase.GAME_OVER);

      // 13. Top bar + bottom bar
      renderTopBar();
      const bottomBar = document.getElementById('bottomBar');
      if (bottomBar) {
        const showBottom = G.phase !== Phase.MODE_SELECT && G.phase !== Phase.GAME_OVER;
        bottomBar.style.display = showBottom ? 'flex' : 'none';
      }

      // 14. Fit board to container (maintain landscape aspect ratio)
      fitBoard();
    }

    // ════════════════════════════════════════════════
    //  DOM CONSTRUCTION (one-time)
    // ════════════════════════════════════════════════

    /**
     * Build the board DOM.
     * When flipped === true (PvAI mode), the board is rotated 180°:
     *  - Top row: points 12..7 | bar | 6..1  (Black's home at top-right)
     *  - Bottom row: points 13..18 | bar | 19..24  (White's home at bottom-right)
     *  - Bar: black checkers on top, white on bottom (swapped)
     *  - Bear-off trays swap sides: white on right (bottom-right), black on left (top-left)
     */
    function buildBoard(flipped) {
      const board = document.getElementById('board');
      board.innerHTML = '';

      // Determine quadrant layout based on orientation
      let topLabelLeft, topLabelRight, botLabelLeft, botLabelRight;
      let quadrants;

      if (flipped) {
        // Flipped: White plays bottom (24→1 bearing off at bottom-right)
        // Top: 12..7 | 6..1     (points go high→low from left→right)
        // Bottom: 13..18 | 19..24  (points go low→high from left→right)
        topLabelLeft  = [12,11,10,9,8,7];
        topLabelRight = [6,5,4,3,2,1];
        botLabelLeft  = [13,14,15,16,17,18];
        botLabelRight = [19,20,21,22,23,24];

        quadrants = [
          { cls: 'top-left top',        points: [12,11,10,9,8,7] },
          { cls: 'top-right top',       points: [6,5,4,3,2,1] },
          { cls: 'bottom-left bottom',  points: [13,14,15,16,17,18] },
          { cls: 'bottom-right bottom', points: [19,20,21,22,23,24] },
        ];
      } else {
        // Normal: points 13-24 on top, 12-1 on bottom
        topLabelLeft  = [13,14,15,16,17,18];
        topLabelRight = [19,20,21,22,23,24];
        botLabelLeft  = [12,11,10,9,8,7];
        botLabelRight = [6,5,4,3,2,1];

        quadrants = [
          { cls: 'top-left top',        points: [13,14,15,16,17,18] },
          { cls: 'top-right top',       points: [19,20,21,22,23,24] },
          { cls: 'bottom-left bottom',  points: [12,11,10,9,8,7] },
          { cls: 'bottom-right bottom', points: [6,5,4,3,2,1] },
        ];
      }

      // Top labels
      const topLabels = document.createElement('div');
      topLabels.className = 'point-labels';
      const topLeft = document.createElement('div');
      topLeft.className = 'point-labels-half';
      for (const p of topLabelLeft) {
        const l = document.createElement('div');
        l.className = 'point-label';
        l.textContent = p;
        topLeft.appendChild(l);
      }
      const topSpacer = document.createElement('div');
      topSpacer.className = 'bar-spacer';
      const topRight = document.createElement('div');
      topRight.className = 'point-labels-half';
      for (const p of topLabelRight) {
        const l = document.createElement('div');
        l.className = 'point-label';
        l.textContent = p;
        topRight.appendChild(l);
      }
      topLabels.appendChild(topLeft);
      topLabels.appendChild(topSpacer);
      topLabels.appendChild(topRight);
      board.appendChild(topLabels);

      // Bar
      const bar = document.createElement('div');
      bar.className = 'bar';
      bar.id = 'barElement';

      if (flipped) {
        // Flipped: black checkers on top, white on bottom
        const barTop = document.createElement('div');
        barTop.className = 'bar-checkers';
        barTop.id = 'barBlack';
        const barBot = document.createElement('div');
        barBot.className = 'bar-checkers';
        barBot.id = 'barWhite';
        bar.appendChild(barTop);
        bar.appendChild(barBot);
      } else {
        // Normal: white checkers on top, black on bottom
        const barTop = document.createElement('div');
        barTop.className = 'bar-checkers';
        barTop.id = 'barWhite';
        const barBot = document.createElement('div');
        barBot.className = 'bar-checkers';
        barBot.id = 'barBlack';
        bar.appendChild(barTop);
        bar.appendChild(barBot);
      }

      bar.addEventListener('click', handleBarClick);
      bar.addEventListener('dblclick', () => handleQuickMove('bar'));

      const els = [];

      for (const q of quadrants) {
        const qEl = document.createElement('div');
        qEl.className = `quadrant ${q.cls}`;

        for (const pointNum of q.points) {
          const point = document.createElement('div');
          const colorCls = pointNum % 2 === 0 ? 'dark' : 'light';
          point.className = `point ${colorCls}`;
          point.dataset.point = pointNum;

          const tri = document.createElement('div');
          tri.className = 'triangle';
          point.appendChild(tri);

          const checkers = document.createElement('div');
          checkers.className = 'checkers';
          point.appendChild(checkers);

          point.addEventListener('click', () => handlePointClick(pointNum));
          point.addEventListener('dblclick', () => handleQuickMove(pointNum));

          qEl.appendChild(point);
        }
        els.push(qEl);
      }

      board.appendChild(els[0]);
      board.appendChild(bar);
      board.appendChild(els[1]);
      board.appendChild(els[2]);
      board.appendChild(els[3]);

      // Bottom labels
      const botLabels = document.createElement('div');
      botLabels.className = 'point-labels';
      const botLeft = document.createElement('div');
      botLeft.className = 'point-labels-half';
      for (const p of botLabelLeft) {
        const l = document.createElement('div');
        l.className = 'point-label';
        l.textContent = p;
        botLeft.appendChild(l);
      }
      const botSpacer = document.createElement('div');
      botSpacer.className = 'bar-spacer';
      const botRight = document.createElement('div');
      botRight.className = 'point-labels-half';
      for (const p of botLabelRight) {
        const l = document.createElement('div');
        l.className = 'point-label';
        l.textContent = p;
        botRight.appendChild(l);
      }
      botLabels.appendChild(botLeft);
      botLabels.appendChild(botSpacer);
      botLabels.appendChild(botRight);
      board.appendChild(botLabels);

    }

    // ════════════════════════════════════════════════
    //  GAME FLOW — Mode selection
    // ════════════════════════════════════════════════

    function selectMode(mode) {
      G.mode = mode;

      // Read player names
      const p1 = document.getElementById('player1Name').value.trim();
      G.playerNames.white = p1 || 'White';

      if (mode === 'pvai') {
        // Read AI difficulty
        const selectedBtn = document.querySelector('.ai-diff-btn.selected');
        G.aiDifficulty = selectedBtn ? selectedBtn.dataset.diff : 'intermediate';

        // AI is always Black
        const diffLabel = capitalize(G.aiDifficulty);
        G.playerNames.black = `AI (${diffLabel})`;
      } else {
        const p2 = document.getElementById('player2Name').value.trim();
        G.playerNames.black = p2 || 'Black';
      }

      // Read cube settings
      const cubeEnabled = document.getElementById('cubeToggle').checked;
      const cubeMax = parseInt(document.getElementById('cubeMaxSelect').value);
      G.cube.enabled = cubeEnabled;
      G.cube.maxValue = cubeMax;
      G.cube.value = 1;
      G.cube.owner = null;

      startNewGame();
    }

    function startNewGame() {
      clearAITimers();
      showAIThinking(false);

      G.phase = Phase.OPENING_ROLL;

      // Screen transition: fade setup → show game
      const setupScreen = document.getElementById('setupScreen');
      const gameScreen = document.getElementById('gameScreen');
      setupScreen.classList.add('hidden');
      gameScreen.classList.remove('removed');
      gameScreen.classList.remove('hidden');
      setTimeout(() => {
        setupScreen.classList.add('removed');
      }, 400);

      // Keep old references working (harmless no-ops on hidden shell elements)
      document.getElementById('modeSelect').classList.add('hidden');
      document.getElementById('controls').classList.remove('hidden');

      // Rebuild board with correct orientation
      buildBoard(G.mode === 'pvai');

      initBoard();

      G.currentPlayer = 'white';
      G.dice.values = [];
      G.dice.remaining = [];
      G.selectedPoint = null;
      G.validMoves = [];
      G.combinedTargets = [];
      G.allLegalMoves = [];
      G.undoStack = [];
      G.graceTimer = null;
      G.cube.value = 1;
      G.cube.owner = null;
      G.doublingTarget = null;

      G.message = 'Rolling to see who goes first...';
      renderBoard();

      setTimeout(performOpeningRoll, 600);
    }

    // ════════════════════════════════════════════════
    //  GAME FLOW — Opening roll
    // ════════════════════════════════════════════════

    function performOpeningRoll() {
      const d1 = document.getElementById('die1');
      const d2 = document.getElementById('die2');
      const f1 = document.getElementById('dieFace1');
      const f2 = document.getElementById('dieFace2');

      d1.classList.remove('used');
      d2.classList.remove('used');
      d1.classList.add('rolling');
      d2.classList.add('rolling');

      playDiceSound();

      const whiteRoll = Math.floor(Math.random() * 6) + 1;
      const blackRoll = Math.floor(Math.random() * 6) + 1;

      setTimeout(() => {
        renderDieFace(f1, whiteRoll);
        renderDieFace(f2, blackRoll);
        d1.classList.remove('rolling');
        d2.classList.remove('rolling');

        if (whiteRoll === blackRoll) {
          G.message = `${pName('white')} ${whiteRoll}, ${pName('black')} ${blackRoll} — Tie! Rolling again...`;
          renderStatus();
          setTimeout(performOpeningRoll, 1600);
          return;
        }

        const winner = whiteRoll > blackRoll ? 'white' : 'black';
        G.currentPlayer = winner;
        G.message = `${pName('white')} ${whiteRoll}, ${pName('black')} ${blackRoll} — ${pName(winner)} goes first!`;
        renderStatus();

        G.dice.values = [whiteRoll, blackRoll];
        G.dice.remaining = [whiteRoll, blackRoll];

        setTimeout(() => {
          G.phase = Phase.MOVING;
          G.undoStack = [];
          G.allLegalMoves = calculateAllLegalMoves();

          if (G.allLegalMoves.length === 0) {
            G.message = `${pName(G.currentPlayer)} has no legal moves!`;
            if (!isAITurn()) playErrorSound();
            renderBoard();
            setTimeout(endTurn, 1500);
          } else if (isAITurn()) {
            // AI goes first after opening roll
            G.message = `${pName('black')} goes first!`;
            renderBoard();
            showAIThinking(true);
            const t = setTimeout(() => {
              showAIThinking(false);
              aiExecuteMoves();
            }, aiDelay());
            G.aiTimers.push(t);
          } else {
            G.message = `${pName(G.currentPlayer)}'s turn — select a checker to move.`;
            renderBoard();
          }
        }, 1800);

      }, 400);
    }

    // ════════════════════════════════════════════════
    //  GAME FLOW — Rolling
    // ════════════════════════════════════════════════

    function handleRollClick() {
      if (G.phase !== Phase.ROLLING) return;
      if (isAITurn()) return; // AI rolls itself

      const rollBtn = document.getElementById('rollBtn');
      rollBtn.disabled = true;

      const d1 = document.getElementById('die1');
      const d2 = document.getElementById('die2');
      d1.classList.remove('used');
      d2.classList.remove('used');
      d1.querySelector('.doubles-badge')?.remove();
      d2.querySelector('.doubles-badge')?.remove();
      d1.classList.add('rolling');
      d2.classList.add('rolling');

      playDiceSound();

      setTimeout(() => {
        const v1 = Math.floor(Math.random() * 6) + 1;
        const v2 = Math.floor(Math.random() * 6) + 1;

        renderDieFace(document.getElementById('dieFace1'), v1);
        renderDieFace(document.getElementById('dieFace2'), v2);

        d1.classList.remove('rolling');
        d2.classList.remove('rolling');

        G.dice.values = [v1, v2];

        if (v1 === v2) {
          G.dice.remaining = [v1, v1, v1, v1];
        } else {
          G.dice.remaining = [v1, v2];
        }

        G.phase = Phase.MOVING;
        G.undoStack = [];
        G.allLegalMoves = calculateAllLegalMoves();

        if (G.allLegalMoves.length === 0) {
          G.message = `${pName(G.currentPlayer)} rolled ${v1} and ${v2} — no legal moves!`;
          playErrorSound();
          renderBoard();
          setTimeout(endTurn, 1500);
        } else {
          const doublesNote = v1 === v2 ? ' (doubles — 4 moves!)' : '';
          G.message = `${pName(G.currentPlayer)} rolled ${v1} and ${v2}${doublesNote} — select a checker.`;
          renderBoard();
        }

        rollBtn.disabled = false;
      }, 400);
    }

    // ════════════════════════════════════════════════
    //  GAME FLOW — Click handlers (with dblclick support)
    // ════════════════════════════════════════════════

    let _clickTimer = null;
    const CLICK_DELAY = 220;

    function handlePointClick(pointNum) {
      if (G.phase !== Phase.MOVING) return;
      if (isAITurn()) return; // Don't allow human clicks during AI turn

      // Immediate actions: clicking a valid target or combined target
      if (G.selectedPoint !== null && G.selectedPoint !== pointNum) {
        const move = G.validMoves.find(m => m.to === pointNum);
        if (move) {
          clearTimeout(_clickTimer);
          executeMove(move);
          return;
        }

        if (G.combinedTargets.includes(pointNum)) {
          clearTimeout(_clickTimer);
          const player = G.currentPlayer;
          const dir = moveDir(player);
          for (const m1 of G.validMoves) {
            if (m1.to === 'off') continue;
            const bCopy = [...G.board];
            applyMove(bCopy, m1, player);
            const rest = [...G.dice.remaining];
            rest.splice(rest.indexOf(m1.dieValue), 1);
            for (const dv of [...new Set(rest)]) {
              const dest = m1.to + dir * dv;
              if (dest === pointNum && canLand(bCopy, dest, player)) {
                executeMove(m1);
                const secondMove = G.allLegalMoves.find(m => m.from === m1.to && m.to === pointNum);
                if (secondMove) {
                  executeMove(secondMove);
                }
                return;
              }
            }
          }
        }
      }

      // Selection / deselection — delay to allow double-click detection
      clearTimeout(_clickTimer);
      _clickTimer = setTimeout(() => {
        _clickTimer = null;
        if (G.phase !== Phase.MOVING) return;

        if (ownsPoint(G.board, pointNum, G.currentPlayer)) {
          const movesFromHere = G.allLegalMoves.filter(m => m.from === pointNum);
          if (movesFromHere.length > 0) {
            if (G.selectedPoint === pointNum) {
              G.selectedPoint = null;
              G.validMoves = [];
              G.combinedTargets = [];
            } else {
              G.selectedPoint = pointNum;
              G.validMoves = movesFromHere;
              G.combinedTargets = calcCombinedTargets(pointNum, movesFromHere);
            }
            renderBoard();
            return;
          }
        }

        G.selectedPoint = null;
        G.validMoves = [];
        G.combinedTargets = [];
        renderBoard();
      }, CLICK_DELAY);
    }

    function handleBarClick() {
      if (G.phase !== Phase.MOVING) return;
      if (isAITurn()) return;
      if (!hasBar(G.currentPlayer)) return;

      const movesFromBar = G.allLegalMoves.filter(m => m.from === 'bar');
      if (movesFromBar.length === 0) return;

      clearTimeout(_clickTimer);
      _clickTimer = setTimeout(() => {
        _clickTimer = null;
        if (G.phase !== Phase.MOVING) return;

        if (G.selectedPoint === 'bar') {
          G.selectedPoint = null;
          G.validMoves = [];
          G.combinedTargets = [];
        } else {
          G.selectedPoint = 'bar';
          G.validMoves = movesFromBar;
          G.combinedTargets = calcCombinedTargets('bar', movesFromBar);
        }
        renderBoard();
      }, CLICK_DELAY);
    }

    // ════════════════════════════════════════════════
    //  GAME FLOW — Bear-off tray click
    // ════════════════════════════════════════════════

    function handleBearOffTrayClick(color) {
      if (G.phase !== Phase.MOVING) return;
      if (isAITurn()) return;
      if (color !== G.currentPlayer) return;

      const bearOffMove = G.validMoves.find(m => m.to === 'off');
      if (bearOffMove) {
        clearTimeout(_clickTimer);
        executeMove(bearOffMove);
      }
    }

    // ════════════════════════════════════════════════
    //  GAME FLOW — Quick move (double-click)
    // ════════════════════════════════════════════════

    function handleQuickMove(from) {
      if (G.phase !== Phase.MOVING) return;
      if (isAITurn()) return;

      clearTimeout(_clickTimer);
      _clickTimer = null;

      const movesFromHere = G.allLegalMoves.filter(m => m.from === from);
      if (movesFromHere.length === 0) return;

      movesFromHere.sort((a, b) => b.dieValue - a.dieValue);

      G.selectedPoint = null;
      G.validMoves = [];
      G.combinedTargets = [];
      executeMove(movesFromHere[0]);
    }

    // ════════════════════════════════════════════════
    //  GAME FLOW — Move execution
    // ════════════════════════════════════════════════

    function executeMove(move) {
      // Cancel any grace period timer
      if (G.graceTimer) {
        clearTimeout(G.graceTimer);
        G.graceTimer = null;
      }

      // Save snapshot for undo before applying the move
      G.undoStack.push({
        board: [...G.board],
        remaining: [...G.dice.remaining],
        borneOff: { ...G.borneOff },
      });

      // Detect blot before applying move (for sound + animation)
      const player = G.currentPlayer;
      const hitBlot = willHitBlot(G.board, move.to, player);
      const opponent = player === 'white' ? 'black' : 'white';
      const isBearOff = move.to === 'off';

      // ── Capture positions BEFORE the move ──
      const srcPos = getCheckerPosition(move.from, player);
      let hitPos = null;
      if (hitBlot && move.to !== 'off') {
        hitPos = getCheckerPosition(move.to, opponent);
      }

      // ── Apply the move to game state ──
      applyMove(G.board, move, player);

      // Sound
      if (hitBlot) {
        playCaptureSound();
      } else {
        playMoveSound();
      }

      // Track bear-off
      if (isBearOff) {
        G.borneOff[player]++;
      }

      // Consume the die
      const idx = G.dice.remaining.indexOf(move.dieValue);
      G.dice.remaining.splice(idx, 1);

      G.selectedPoint = null;
      G.validMoves = [];
      G.combinedTargets = [];

      // ── Determine post-move state (before rendering) ──
      const isWin = G.borneOff[player] === 15;
      const allDiceUsed = G.dice.remaining.length === 0;
      let noMoreMoves = false;

      if (isWin) {
        G.phase = Phase.GAME_OVER;
        G.allLegalMoves = [];
        G.message = `${pName(player)} wins!`;
      } else if (allDiceUsed) {
        G.allLegalMoves = [];
      } else {
        G.allLegalMoves = calculateAllLegalMoves();
        noMoreMoves = G.allLegalMoves.length === 0;
      }

      // ── Render the board with the new state ──
      if (!isWin && !allDiceUsed && !noMoreMoves) {
        const remStr = G.dice.remaining.join(', ');
        G.message = `${pName(player)} — remaining dice: ${remStr}`;
      }
      renderBoard();

      // ── Animate checker movement ──
      const destPos = isBearOff
        ? getCheckerPosition('off', player)
        : getCheckerPosition(move.to, player);

      // Run animation (non-blocking for game flow)
      const runAnimation = async () => {
        const promises = [];

        // Main checker animation
        if (srcPos && destPos) {
          promises.push(animateChecker(srcPos, destPos, player, isBearOff));
        }

        // Hit blot animation (opponent checker to bar)
        if (hitBlot && hitPos) {
          const barDest = getCheckerPosition('bar', opponent);
          if (barDest) {
            promises.push(animateChecker(hitPos, barDest, opponent, false));
          }
        }

        await Promise.all(promises);
      };

      runAnimation();

      // ── Handle post-move game flow ──
      if (isWin) {
        setTimeout(() => triggerWin(player, 'bearoff'), 400);
        return;
      }

      if (allDiceUsed) {
        startGracePeriod();
        return;
      }

      if (noMoreMoves) {
        if (!isAITurn()) playErrorSound();
        if (G.undoStack.length > 0) {
          startGracePeriod();
        } else {
          G.message = `No more legal moves. Switching turns...`;
          renderBoard();
          setTimeout(endTurn, 1200);
        }
        return;
      }
    }

    // ════════════════════════════════════════════════
    //  GAME FLOW — Grace Period
    // ════════════════════════════════════════════════

    function startGracePeriod() {
      // Skip grace period for AI — end turn immediately
      if (isAITurn()) {
        G.message = `${pName('black')}'s turn complete.`;
        renderBoard();
        const t = setTimeout(endTurn, 600);
        G.aiTimers.push(t);
        return;
      }

      G.message = `${pName(G.currentPlayer)}'s turn complete — passing in 1.5s...`;
      renderBoard();

      G.graceTimer = setTimeout(function () {
        G.graceTimer = null;
        endTurn();
      }, 1500);
    }

    // ════════════════════════════════════════════════
    //  GAME FLOW — Undo
    // ════════════════════════════════════════════════

    function handleUndo() {
      if (G.undoStack.length === 0 || G.phase !== Phase.MOVING) return;
      if (isAITurn()) return; // No undo during AI turn

      // Cancel grace period
      if (G.graceTimer) {
        clearTimeout(G.graceTimer);
        G.graceTimer = null;
      }

      const snapshot = G.undoStack.pop();
      G.board = snapshot.board;
      G.dice.remaining = snapshot.remaining;
      G.borneOff = snapshot.borneOff;

      G.selectedPoint = null;
      G.validMoves = [];
      G.combinedTargets = [];
      G.allLegalMoves = calculateAllLegalMoves();

      const remStr = G.dice.remaining.join(', ');
      G.message = `${pName(G.currentPlayer)} — undid last move. Dice: ${remStr}`;
      renderBoard();
    }

    // ════════════════════════════════════════════════
    //  GAME FLOW — Turn management
    // ════════════════════════════════════════════════

    function endTurn() {
      // Clear any lingering grace timer
      if (G.graceTimer) {
        clearTimeout(G.graceTimer);
        G.graceTimer = null;
      }

      G.currentPlayer = G.currentPlayer === 'white' ? 'black' : 'white';
      G.phase = Phase.ROLLING;
      G.selectedPoint = null;
      G.validMoves = [];
      G.combinedTargets = [];
      G.allLegalMoves = [];
      G.dice.values = [];
      G.dice.remaining = [];
      G.undoStack = [];

      // AI turn
      if (isAITurn()) {
        G.message = `${pName('black')}'s turn...`;
        renderBoard();
        const t = setTimeout(() => aiTakeTurn(), 500);
        G.aiTimers.push(t);
        return;
      }

      if (G.autoRoll) {
        G.message = `${pName(G.currentPlayer)}'s turn — auto-rolling...`;
        renderBoard();
        setTimeout(handleRollClick, 500);
      } else {
        G.message = `${pName(G.currentPlayer)}'s turn — roll the dice.`;
        renderBoard();
      }
    }

    // ════════════════════════════════════════════════
    //  GAME FLOW — Doubling Cube
    // ════════════════════════════════════════════════

    function handleDouble() {
      if (G.phase !== Phase.ROLLING) return;
      if (!G.cube.enabled) return;
      // Allow both human and AI to call this function

      const canDouble = G.cube.owner === null || G.cube.owner === G.currentPlayer;
      const nextValue = G.cube.value * 2;
      if (!canDouble || nextValue > G.cube.maxValue) return;

      // Show doubling overlay
      const opponent = G.currentPlayer === 'white' ? 'black' : 'white';
      G.doublingTarget = opponent;
      G.phase = Phase.DOUBLING;

      const titleEl = document.getElementById('doublingTitle');
      titleEl.textContent = `${pName(G.currentPlayer)} Offers to Double!`;

      const textEl = document.getElementById('doublingText');
      textEl.textContent = `${pName(opponent)}, do you accept the double?`;

      const cubeEl = document.getElementById('doublingCubeValue');
      cubeEl.textContent = nextValue;

      document.getElementById('doublingOverlay').classList.add('visible');
      renderBoard();

      // If AI is the doubling target, have AI auto-respond
      if (G.mode === 'pvai' && G.doublingTarget === 'black') {
        // Hide overlay buttons from AI perspective (AI will auto-decide)
        document.getElementById('doublingOverlay').classList.remove('visible');
        aiRespondToDouble();
        return;
      }
    }

    function handleAcceptDouble() {
      const opponent = G.doublingTarget;
      G.cube.value *= 2;
      G.cube.owner = opponent; // ownership goes to the accepting player

      G.doublingTarget = null;
      document.getElementById('doublingOverlay').classList.remove('visible');

      // Continue to rolling phase
      G.phase = Phase.ROLLING;
      G.message = `${pName(opponent)} accepted the double! Cube is now ${G.cube.value}. ${pName(G.currentPlayer)}'s turn.`;

      // If it's AI's turn to roll after accepting, trigger AI
      if (isAITurn()) {
        renderBoard();
        const t = setTimeout(() => aiRollDice(), aiDelay());
        G.aiTimers.push(t);
      } else if (G.autoRoll) {
        renderBoard();
        setTimeout(handleRollClick, 500);
      } else {
        renderBoard();
      }
    }

    function handleDeclineDouble() {
      // Declining player forfeits — doubling player wins with current cube value
      const winner = G.currentPlayer;
      const decliner = G.doublingTarget;
      const points = 1 * G.cube.value; // normal win value before the proposed double

      G.doublingTarget = null;
      document.getElementById('doublingOverlay').classList.remove('visible');

      G.phase = Phase.GAME_OVER;
      G.allLegalMoves = [];
      G.message = `${pName(decliner)} declined the double. ${pName(winner)} wins!`;
      renderBoard();

      // Award points and show celebration
      G.score[winner] += points;
      setTimeout(() => showWinCelebration(winner, 'normal', points), 400);
    }

    // ════════════════════════════════════════════════
    //  GAME FLOW — Surrender
    // ════════════════════════════════════════════════

    function handleSurrender() {
      if (G.phase !== Phase.ROLLING && G.phase !== Phase.MOVING) return;
      if (isAITurn()) return; // AI doesn't use surrender button

      const opponent = G.currentPlayer === 'white' ? 'black' : 'white';
      const textEl = document.getElementById('surrenderText');
      textEl.textContent = `Are you sure? ${pName(opponent)} will win the game.`;

      document.getElementById('surrenderOverlay').classList.add('visible');
    }

    function confirmSurrender() {
      document.getElementById('surrenderOverlay').classList.remove('visible');

      // Cancel grace period
      if (G.graceTimer) {
        clearTimeout(G.graceTimer);
        G.graceTimer = null;
      }

      const winner = G.currentPlayer === 'white' ? 'black' : 'white';
      const points = 1 * G.cube.value; // normal win on surrender

      G.phase = Phase.GAME_OVER;
      G.allLegalMoves = [];
      G.message = `${pName(G.currentPlayer)} surrendered. ${pName(winner)} wins!`;
      renderBoard();

      G.score[winner] += points;
      setTimeout(() => showWinCelebration(winner, 'normal', points), 400);
    }

    function cancelSurrender() {
      document.getElementById('surrenderOverlay').classList.remove('visible');
    }

    // ════════════════════════════════════════════════
    //  WIN — Trigger & Celebration
    // ════════════════════════════════════════════════

    /**
     * Called when a player wins by bearing off all 15 checkers.
     */
    function triggerWin(winner, reason) {
      const winInfo = calculateWinType(winner);
      const cubeMultiplier = G.cube.enabled ? G.cube.value : 1;
      const totalPoints = winInfo.multiplier * cubeMultiplier;

      G.score[winner] += totalPoints;
      showWinCelebration(winner, winInfo.type, totalPoints);
    }

    let confettiAnimId = null;

    function showWinCelebration(winner, winType, points) {
      const overlay = document.getElementById('winOverlay');
      const textEl = document.getElementById('winnerText');

      textEl.textContent = `${pName(winner)} Wins!`;
      textEl.className = `winner-text ${winner}-wins`;

      // Win type label
      const typeLabel = document.getElementById('winTypeLabel');
      if (winType === 'backgammon') {
        typeLabel.textContent = 'Backgammon!';
        typeLabel.className = 'win-type-label backgammon';
      } else if (winType === 'gammon') {
        typeLabel.textContent = 'Gammon!';
        typeLabel.className = 'win-type-label gammon';
      } else {
        typeLabel.textContent = 'Normal Win';
        typeLabel.className = 'win-type-label normal';
      }

      // Points info
      const pointsInfo = document.getElementById('winPointsInfo');
      if (G.cube.enabled && G.cube.value > 1) {
        const baseMultiplier = winType === 'backgammon' ? 3 : winType === 'gammon' ? 2 : 1;
        pointsInfo.textContent = `${baseMultiplier} × ${G.cube.value} (cube) = ${points} point${points !== 1 ? 's' : ''}`;
      } else {
        pointsInfo.textContent = `+${points} point${points !== 1 ? 's' : ''}`;
      }

      overlay.classList.add('visible');
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          overlay.classList.add('fade-in');
        });
      });

      startConfetti(winner);
      playVictoryFanfare();
      document.body.classList.add('win-active');

      // Update scoreboard
      renderScoreboard();
    }

    function hideWinCelebration() {
      const overlay = document.getElementById('winOverlay');
      overlay.classList.remove('visible', 'fade-in');
      stopConfetti();
      document.body.classList.remove('win-active');
    }

    function startConfetti(winner) {
      const canvas = document.getElementById('confettiCanvas');
      const ctx = canvas.getContext('2d');

      function resize() {
        canvas.width = DESIGN_W;
        canvas.height = DESIGN_H;
      }
      resize();

      const whiteColors = [
        '#ffffff', '#f0f0f0', '#e0d8c8', '#c9a96e', '#dfc08a',
        '#f5e6c8', '#fffbe6', '#b8b8b8', '#ffd700',
      ];
      const blackColors = [
        '#555555', '#777777', '#999999', '#c9a96e', '#dfc08a',
        '#444444', '#888888', '#aaaaaa', '#ffd700',
      ];
      const colors = winner === 'white' ? whiteColors : blackColors;

      const particles = [];
      const PARTICLE_COUNT = 180;

      for (let i = 0; i < PARTICLE_COUNT; i++) {
        particles.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height - canvas.height,
          vx: (Math.random() - 0.5) * 4,
          vy: Math.random() * 3 + 2,
          size: Math.random() * 8 + 3,
          color: colors[Math.floor(Math.random() * colors.length)],
          rotation: Math.random() * 360,
          rotSpeed: (Math.random() - 0.5) * 8,
          shape: Math.random() < 0.5 ? 'rect' : 'circle',
          wobble: Math.random() * Math.PI * 2,
          wobbleSpeed: Math.random() * 0.05 + 0.02,
          opacity: Math.random() * 0.4 + 0.6,
        });
      }

      function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        for (const p of particles) {
          p.wobble += p.wobbleSpeed;
          p.x += p.vx + Math.sin(p.wobble) * 0.8;
          p.y += p.vy;
          p.rotation += p.rotSpeed;
          p.vy += 0.04;

          if (p.y > canvas.height + 20) {
            p.y = -20;
            p.x = Math.random() * canvas.width;
            p.vy = Math.random() * 3 + 2;
          }

          ctx.save();
          ctx.translate(p.x, p.y);
          ctx.rotate((p.rotation * Math.PI) / 180);
          ctx.globalAlpha = p.opacity;
          ctx.fillStyle = p.color;

          if (p.shape === 'rect') {
            ctx.fillRect(-p.size / 2, -p.size / 4, p.size, p.size / 2);
          } else {
            ctx.beginPath();
            ctx.arc(0, 0, p.size / 2, 0, Math.PI * 2);
            ctx.fill();
          }

          ctx.restore();
        }

        confettiAnimId = requestAnimationFrame(animate);
      }

      animate();
    }

    function stopConfetti() {
      if (confettiAnimId) {
        cancelAnimationFrame(confettiAnimId);
        confettiAnimId = null;
      }
      const canvas = document.getElementById('confettiCanvas');
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    }

    function playAgain() {
      hideWinCelebration();
      clearAITimers();
      showAIThinking(false);

      // Keep score, keep mode, keep cube settings — just restart the game
      startNewGame();
    }

    function newMatch() {
      hideWinCelebration();

      // Clear AI timers
      clearAITimers();
      showAIThinking(false);

      // Full reset including score
      G.phase = Phase.MODE_SELECT;
      G.mode = null;
      G.currentPlayer = 'white';
      G.dice.values = [];
      G.dice.remaining = [];
      G.selectedPoint = null;
      G.validMoves = [];
      G.combinedTargets = [];
      G.allLegalMoves = [];
      G.message = '';
      G.undoStack = [];
      G.autoRoll = false;
      G.score = { white: 0, black: 0 };
      G.cube = { value: 1, owner: null, enabled: false, maxValue: 64 };
      G.graceTimer = null;
      G.doublingTarget = null;
      G.playerNames = { white: 'White', black: 'Black' };
      G.aiDifficulty = 'intermediate';
      G.aiThinking = false;

      initBoard();
      buildBoard(false); // Reset to normal orientation

      document.getElementById('modeSelect').classList.remove('hidden');
      document.getElementById('controls').classList.add('hidden');
      document.getElementById('autoRollToggle').checked = false;
      document.getElementById('soundToggle').checked = true;
      document.getElementById('cubeToggle').checked = false;
      document.getElementById('cubeMaxWrapper').classList.remove('visible');
      document.getElementById('cubeMaxSelect').value = '64';
      document.getElementById('player1Name').value = '';
      document.getElementById('player2Name').value = '';
      document.querySelectorAll('.ai-diff-btn').forEach(b => b.classList.remove('selected'));
      document.querySelector('.ai-diff-btn[data-diff="intermediate"]').classList.add('selected');

      // Screen transition: fade game → show setup
      const gameScreen = document.getElementById('gameScreen');
      const setupScreen = document.getElementById('setupScreen');
      gameScreen.classList.add('hidden');
      setupScreen.classList.remove('removed');
      setupScreen.classList.remove('hidden');
      setTimeout(() => {
        gameScreen.classList.add('removed');
      }, 400);

      // Reset icon toggle visuals
      updateIconToggles();

      // Reset mode preview to PvP
      selectedModePreview = 'pvp';
      previewMode('pvp');

      renderBoard();
    }

    // ════════════════════════════════════════════════
    //  INIT
    // ════════════════════════════════════════════════

    /** Currently selected mode on the settings screen (before starting). */
    let selectedModePreview = 'pvp';

    // ════════════════════════════════════════════════
    //  AVATAR STATE & SVGs
    // ════════════════════════════════════════════════

    let selectedAvatarWhite = 'crown';
    let selectedAvatarBlack = 'shield';

    const AVATAR_SVGS = {
      crown:     '<svg viewBox="0 0 24 24"><path d="M3 18h18v2H3v-2zm-.5-2L6 8l4.5 4L12 4l1.5 8L18 8l3.5 8H2.5z"/></svg>',
      sword:     '<svg viewBox="0 0 24 24"><path d="M14.12 4l1.83 1.83-6.19 6.18-2.83-2.83L14.12 4M17.5 2l-8.49 8.49 3.54 3.54L21 5.59V2h-3.5zM2 19.59l3.17-3.17 3.54 3.54L5.54 23.13 2 19.59z"/></svg>',
      shield:    '<svg viewBox="0 0 24 24"><path d="M12 1L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4z"/></svg>',
      star:      '<svg viewBox="0 0 24 24"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87L18.18 22 12 18.27 5.82 22 7 14.14l-5-4.87 6.91-1.01L12 2z"/></svg>',
      flame:     '<svg viewBox="0 0 24 24"><path d="M12 23c-4.97 0-9-3.58-9-8 0-3.07 2.13-5.83 4-7.41V6c0-3.31 2.69-6 6-6 .34 0 .67.03 1 .08C12.7 1.43 12 3.15 12 5c0 3.31 2.69 6 6 6 .34 0 .67-.03 1-.08-.26 4.46-3.5 8.71-7 12.08z"/></svg>',
      knight:    '<svg viewBox="0 0 24 24"><path d="M19 22H5v-2h14v2M13 2c-1.25 0-2.42.62-3.11 1.66L7 8l2 2-3 5h2l3-4.5 1 .5V18h4V9l2-4c.39-.78.39-1.72 0-2.5C17.61 1.4 15.78.65 14 2h-1z"/></svg>',
      lightning: '<svg viewBox="0 0 24 24"><path d="M7 2v11h3v9l7-12h-4l4-8H7z"/></svg>',
      diamond:   '<svg viewBox="0 0 24 24"><path d="M12 2L2 12l10 10 10-10L12 2zm0 3l7 7-7 7-7-7 7-7z"/></svg>',
    };

    function getAvatarSVG(iconName) {
      return AVATAR_SVGS[iconName] || AVATAR_SVGS.crown;
    }

    // ════════════════════════════════════════════════
    //  TOP BAR RENDERING
    // ════════════════════════════════════════════════

    function renderTopBar() {
      if (G.phase === Phase.MODE_SELECT) return;

      const nameP1 = document.getElementById('topBarNameP1');
      const nameP2 = document.getElementById('topBarNameP2');
      if (nameP1) nameP1.textContent = pName('white');
      if (nameP2) nameP2.textContent = pName('black');

      const avatarP1 = document.getElementById('topBarAvatarP1');
      const avatarP2 = document.getElementById('topBarAvatarP2');
      if (avatarP1) avatarP1.innerHTML = getAvatarSVG(selectedAvatarWhite);
      if (avatarP2) avatarP2.innerHTML = getAvatarSVG(selectedAvatarBlack);

      const p1Section = document.getElementById('topBarP1');
      const p2Section = document.getElementById('topBarP2');
      if (p1Section && p2Section) {
        p1Section.classList.toggle('active', G.currentPlayer === 'white');
        p2Section.classList.toggle('active', G.currentPlayer === 'black');
      }
    }

    /** Update settings UI when clicking mode buttons. */
    function previewMode(mode) {
      selectedModePreview = mode;
      const p2Field = document.getElementById('player2Field');
      const aiSettings = document.getElementById('aiSettings');
      const btnPvP = document.getElementById('btnPvP');
      const btnPvAI = document.getElementById('btnPvAI');

      btnPvP.classList.toggle('active', mode === 'pvp');
      btnPvAI.classList.toggle('active', mode === 'pvai');

      if (mode === 'pvai') {
        p2Field.style.display = 'none';
        aiSettings.classList.add('visible');
      } else {
        p2Field.style.display = '';
        aiSettings.classList.remove('visible');
      }
    }

    /** Update icon toggle visual states (active class for gold highlight). */
    function updateIconToggles() {
      const autoEl = document.getElementById('autoRollIconToggle');
      const soundEl = document.getElementById('soundIconToggle');
      if (autoEl) autoEl.classList.toggle('active', document.getElementById('autoRollToggle').checked);
      if (soundEl) soundEl.classList.toggle('active', document.getElementById('soundToggle').checked);
    }

    function init() {
      initBoard();
      buildBoard(false);
      renderBoard();

      // Mode selection buttons — clicking toggles preview (doesn't start game)
      document.getElementById('btnPvP').addEventListener('click', () => previewMode('pvp'));
      document.getElementById('btnPvAI').addEventListener('click', () => previewMode('pvai'));

      // Start game button
      document.getElementById('btnStartGame').addEventListener('click', () => selectMode(selectedModePreview));

      // AI difficulty buttons
      document.querySelectorAll('.ai-diff-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          document.querySelectorAll('.ai-diff-btn').forEach(b => b.classList.remove('selected'));
          btn.classList.add('selected');
        });
      });

      document.getElementById('rollBtn').addEventListener('click', handleRollClick);
      document.getElementById('undoBtn').addEventListener('click', handleUndo);

      // Bear-off tray clicks
      document.getElementById('trayWhite').addEventListener('click', () => handleBearOffTrayClick('white'));
      document.getElementById('trayBlack').addEventListener('click', () => handleBearOffTrayClick('black'));

      // Double button
      document.getElementById('doubleBtn').addEventListener('click', handleDouble);

      // Doubling overlay
      document.getElementById('acceptDoubleBtn').addEventListener('click', handleAcceptDouble);
      document.getElementById('declineDoubleBtn').addEventListener('click', handleDeclineDouble);

      // Surrender
      document.getElementById('surrenderBtn').addEventListener('click', handleSurrender);
      document.getElementById('confirmSurrenderBtn').addEventListener('click', confirmSurrender);
      document.getElementById('cancelSurrenderBtn').addEventListener('click', cancelSurrender);

      // Play Again & New Match
      document.getElementById('playAgainBtn').addEventListener('click', playAgain);
      document.getElementById('newMatchBtn').addEventListener('click', newMatch);

      // Auto-roll toggle
      const autoRollToggle = document.getElementById('autoRollToggle');
      autoRollToggle.addEventListener('change', () => {
        G.autoRoll = autoRollToggle.checked;
        updateIconToggles();
        renderBoard();
        if (G.autoRoll && G.phase === Phase.ROLLING) {
          setTimeout(handleRollClick, 300);
        }
      });

      // Sound toggle
      const soundToggle = document.getElementById('soundToggle');
      soundToggle.addEventListener('change', () => {
        G.soundEnabled = soundToggle.checked;
        updateIconToggles();
      });

      // Cube settings toggle
      const cubeToggle = document.getElementById('cubeToggle');
      cubeToggle.addEventListener('change', () => {
        document.getElementById('cubeMaxWrapper').classList.toggle('visible', cubeToggle.checked);
      });

      // Avatar pickers
      document.querySelectorAll('#avatarPickerWhite .avatar-option').forEach(btn => {
        btn.addEventListener('click', () => {
          document.querySelectorAll('#avatarPickerWhite .avatar-option').forEach(b => b.classList.remove('selected'));
          btn.classList.add('selected');
          selectedAvatarWhite = btn.dataset.icon;
        });
      });
      document.querySelectorAll('#avatarPickerBlack .avatar-option').forEach(btn => {
        btn.addEventListener('click', () => {
          document.querySelectorAll('#avatarPickerBlack .avatar-option').forEach(b => b.classList.remove('selected'));
          btn.classList.add('selected');
          selectedAvatarBlack = btn.dataset.icon;
        });
      });

      // Icon toggle visuals
      updateIconToggles();

      // Resize listener — recalculate checker overlap on viewport change
      let resizeTimer = null;
      window.addEventListener('resize', () => {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(() => {
          if (G.phase !== Phase.MODE_SELECT) {
            renderBoard();
          }
        }, 150);
      });
    }

    init();
  </script>
</body>
</html>
